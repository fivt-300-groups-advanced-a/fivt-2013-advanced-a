[0]1. Понять структуру дерева:
[0]1.1 прочитать конспекты про дерево отрезков
+[0]1.2 написать (найти) простое дерево,
+[0]1.3 понять, что мы вообще должны хранить НАРИСОВАТЬ КАРТИНКУ

[0]2. Мозговой штурм всех возможных запросов на отрезке; вывести требования к операциям, вывести взаимоотношения операций;

[0]3. Перерисовать картинку после понимания особенностей операций;

[0]4. Придумать операции, которые можно использовать в тестировании
(подсчёт высоты, подсчёт количества элементов)

+[0]5. Придумать структуру проекта (ну то есть чтоб код тестов в своей папке, генераторы внутри (да-да-да, настало время прочитать ещё чуть-чуть документации googletest))

II.2, II.3 [1]6. Начать писать обобщённое дерево с unittestами
•хмм, inline-функции для вычисления индексов
•мучение с конструкторами GeneralTree
//хмм, вот оно чо, михалыч https://cloudtips.org/introduction-to-rvalue-references.html
    +default constructor (результат как после reset)
    +конструктор копирования,
    +конструктор перемещения,
    +деструктор
Функции build (вобще говоря, их можно бы сделать конструкторами, но, во-первых, компилятор страдает при выборе нужного конструктора (что влечёт к упоротым ошибкам и костылям, особенно если вы хотите хранить size_t, а во-вторых, так как тип сделан копируемым и перемещаемым, то функция инциализации именно в виде функции вполне естественна и полезна)
    +build от (функторы, размер, дефолтные значения res и meta)
    +build_from_range от (функторы, iterator first, iterator last (значения res), дефолтное значение meta);
+•метод reset
•метод get_length
•сложный метод - get
•сложный метод - update(причём подумать над update ind и update [l;r])
Не забывай случаи маленьких мерзких запросов типа {--[====]---}, [---{==]---}
И да, спецфункторы можно использовать уже на этом этапе (Сделать тесты читаемее — TestAccess из предыдущего задания был отвратителен)

I[0.5]7. Написать какой-нибудь примитивный функтор, сдать на informatics

II[2]8. Оттестить структуру дерева
II.1[1]8.1 Сравнение с какой-нибудь медленной примитивной структурой; запросы на маленьких отрезках вида «давайте позапрашиваем вообще всё что возможно»
II.3[1]8.2 Много-много больших тестов с разными примитивными функторами, функторами, призванными тестить, и т. д. 

I[1.5]9. Написать все простые функторы из Т/З, отдельно их оттестить (не глядя на структуру дерева, ибо предполагается, что дерево и так работает)
I[0.5/3]9.1.1 минимум присвоить
I[0.5/3]9.1.2 максимум присвоить
I[0.5/3]9.1.3 сумма присвоить
I[0.5/3]9.2.1 минимум прибавить
I[0.5/3]9.2.2 максимум прибавить
I[0.5/3]9.2.3 сумма прибавить
I[0.5/3]9.3.1 минимум присвоить и прибавить
I[0.5/3]9.3.2 максимум присвоить и прибавить
I[0.5/3]9.3.3 сумма присвоить и прибавить
Вполне вероятно, что 9.1, 9.2, 9.3 нужно писать в виде одного дерева


III, IV [5]10. Написать сложные функторы из т/з
    IV[0.5]10.1.1 отрезки постоянности с присвоением и прибавлением
      IV[2]10.1.2 тесты отрезков постоянности
   III[0.5]10.2.1 отрезки максимальной суммы с присвоением
     III[2]10.2.2 тесты отрезков максимальной суммы

III, IV [eps]11. Написать вообще все функторы во всех сочетаниях, которые приходят в голову; нафигачить разных типов, типа матрицы и перемножение
Видимо, компенсация того, что я не напишу сложные функторы из т/з :(

12* Реализовать специализации шаблонов (ну из разряда заменить дерево отрезков на дерево фенвика для скорости)