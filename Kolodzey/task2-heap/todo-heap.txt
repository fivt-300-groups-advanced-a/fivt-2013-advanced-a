Маленькие открытия — класс сам себе друг :)

Операции, которые поддерживает куча:

//возвращает элемент с наименьшим ключом
//Если их несколько? — возвращает первый, который найдёт.
+reference& top()

-const_reference& top() const;

//удаляет первый минимальный элемент, который найдёт.
Зы — первый — лежащий в куче самого маленького размера.
Возвращает успех операции
void pop_top()


bool decrease_key(iterator position, newKeyValue) //ненадёжная ф-ия какая-то…
Ну ок, возвращает успех операции (во-первых, что iterator в нужное место указывает, во-вторых — что новое значение ключа действительно меньше старого, в-третьих — что просто ничего не упало)

bool delete(iterator position) (возвращает успех операции, ну то есть, что iterator указывает куда надо)

void insert(value)

void insert(binom_heap b) присоединяет кучу b к исходной, а кучу b делает пустой

void insert_copy(binom_heap b) присоединяет копию кучи b (работает долго. за o(b.size()))

конструктор от двух куч(binom_heap a, binom_heap b)
size()
empty()
clear()
iterator beg()
iterator end()

Constructor
Destructor
operator = (копирование или перемещение?)


Конструкторы
------------

BinomialHeap <T> () = пустая куча для элементов типа T со сравнением std::less<T>

BinomialHeap <T, Compare> (Compare mycmp) = пустая куча для элементов типа T со сравнением mycmp

BinomialHeap (BinomialHeap h1, BinomialHeap h2) = куча, полученная слиянием двух куч: h1 и h2. Важно: h1 и h2 имеют одинаковый тип и компаратор! При таком слиянии кучи h1 и h2 уничтожаются.

??? Конструктор перемещения.
??? Запрет конструктора копирования.

Оператор присваивания???



Деструктор
----------
???


Итераторы
---------
begin
end
Для типа предусмотрен random access iterator


Размер
------
empty
size


Изменения
---------
bool insert(T value)
bool absorb(&BinomialHeap child_heap)
*: bool absorb_copy(&BinomialHeap child_heap)
bool pop_top()
bool erase(BinomialHeap::iterator)
&T top()
*: const &T top() const 
void clear()


так блин, закожу ли я это когда-нибудь???
=========================================

Класс ValHolder (объявление, конструктор)
Тест конструктора

Класс ValPointer 
Тест конструктора

Класс BinTree
  Конструкторы, тест конструктора
  Метод eat, тесты метода eat (), проверка инварианта размеров

  Метод clear(), тесты на memory leak

  Функция rehang (в классе BinTreeFunctions)
    !Тесты rehang!!!, тесты rehang с eat

  Метод is_son() + Тесты + тест на скорость

  Метод lift() + Teсты + тест на скорость

  Функция merge (от компаратора, в классе BinTreeFunctions)
    тесты merge (+ тест на инвариант)

  Функция CutRoot (в классе BinTreeFunctions)
    тесты cutRoot + ещё один тест на утечки памяти

Поразвлекаться с private, friend и так далее.
Поразвлекаться с const.
Поразвлекаться с try catch.

Тесты разных типов

Генерация кучи необходимой высоты

Класс BinHeap
    Конструкторы, тесты конструкторов
    Простые операции типа size, empty

    insert_bin_tree()
    проверка структуры
    insert()
    Тест на инварианты pointerа, проверка стуктуры, проверка скорости
    insert_list()
    eat()
    Всё те же тесты, как к insert, +проверка операций size, empty
    find_tree()
    Тесты на всякие случаи
    Операция erase - инварианты, память
    Операция clear — память
    Поиск top, удаление top

Интегрейшн:

Огромный тест тупо засечь время

Огромный тест, с проверкой инвариантов
  +кучесть
  +размеры (размеры деревьев, и размеры детей деревьев)
  +утечки памяти

Тесты на использование кучи как кучи (поискать на информатиксе задачи на кучи, дейкстра с кучей, сортировка кучей, ближайшие к данной точки (тест на состояние компаратора))

Сравнение кучи с медленным аналогом (проверка top и т. п.)

Тесты на слияние: генерация куч необходимой высоты, слияние, потом расфигачивание этого списка, добавление некоторого количества вновь сгенерированных, снова слияние

Тест добавление элемента

Тест удаление элемента

Тест удаление/добавление элемента

Тесты на утечки памяти с clear()

утащить к себе http://informatics.mccme.ru/moodle/mod/statements/view.php?chapterid=755

+скопипастить тесты с информатикса в папку с тестами.
+запустить на них решение краскевича, ну и получить ответы.



 ===планы на последнюю ночь===

+1.1 написать size()
+1.2 потестить size()

+1,3.1 проверить, что будет при присваивании
-1,3.2(в идеале — сделать тип moveable, но не copiable)

+1.4 Поставить const?

1,5.1 проверка инвариантов размера.
1,5.2 проверка инвариантов кучести.
1,5.3 большой стресс-тест в котором проверяются инварианты 

3.1 потестить свой компаратор с состоянием (посортить точки по расстоянию от какой-нибудь, ручной тест)
3.2 проверить, что будет при объединении куч с компараторами в разных состояниях
3.3 использовать кучу для написания выпуклой оболчки

4.1 аццкий мёрдж (создать кучу на 100500 элементов, разбивать её на куски и снова склеивать)
4.2 написать псевдодеревья с неправильным уровнем и мержить кучи с псевдодеревьями

5. удаление элемента: много-много добавлений и удалений, а потом сверить элементы с SET-ом

6. тысяча случайных операций над biheap и dummyheap

***
написать разыменовывание valpointer? (не в этот раз)
Итерирование по куче? (щито? Нет, круто, конечно, уметь выводить все элементы кучи но идеологически контейнер этого не предусматривает)
Радует, что memory leak тестить не ннадо: всё unique_ptr делают

***
I + (в том интегрейшн тесте, что уже есть не хватает merge и delete; это пункты 5 и 4; но всё равно не хватает проверки всех операций в совокупности) -> напиши пункт 6; напиши 4.1*

done 4.2 + куча мелких тестов II + (написаны ручные тесты; думаю, написать хитрый контроль merge 4.2 будет достаточно)

III +
напиши проверку кучести (то бишь сравнение); +
проверку совпадения уровней и количества детей, проверку совпадения уровней детей с уровнем, который ожидает от них родитель; +
проверка правильности ссылок на родителей (и отсутствия ссылки у корня дерева); +
проверку совпадения уровня деревьев с списке _forest и количества элементов, которое независимо считается в переменной _size)+

+ К этой ерунде нужно написать какой-то тест с кучей запросов!

done 3.1 done 3.3 IV + (есть ручные тесты) напиши пункты 3.1 и 3.3; ну и пункт 3.2 можно чисто из интереса проверить, но будет, видимо, примерно как с присваиванием, только без падения на этапе компиляции (ну и как исправлять непонятно)

done! V + (напиши 5)