Маленькие открытия — класс сам себе друг :)

Операции, которые поддерживает куча:

//возвращает элемент с наименьшим ключом
//Если их несколько? — возвращает первый, который найдёт.
+reference& top()

-const_reference& top() const;

//удаляет первый минимальный элемент, который найдёт.
Зы — первый — лежащий в куче самого маленького размера.
Возвращает успех операции
void pop_top()


bool decrease_key(iterator position, newKeyValue) //ненадёжная ф-ия какая-то…
Ну ок, возвращает успех операции (во-первых, что iterator в нужное место указывает, во-вторых — что новое значение ключа действительно меньше старого, в-третьих — что просто ничего не упало)

bool delete(iterator position) (возвращает успех операции, ну то есть, что iterator указывает куда надо)

void insert(value)

void insert(binom_heap b) присоединяет кучу b к исходной, а кучу b делает пустой

void insert_copy(binom_heap b) присоединяет копию кучи b (работает долго. за o(b.size()))

конструктор от двух куч(binom_heap a, binom_heap b)
size()
empty()
clear()
iterator beg()
iterator end()

Constructor
Destructor
operator = (копирование или перемещение?)


Конструкторы
------------

BinomialHeap <T> () = пустая куча для элементов типа T со сравнением std::less<T>

BinomialHeap <T, Compare> (Compare mycmp) = пустая куча для элементов типа T со сравнением mycmp

BinomialHeap (BinomialHeap h1, BinomialHeap h2) = куча, полученная слиянием двух куч: h1 и h2. Важно: h1 и h2 имеют одинаковый тип и компаратор! При таком слиянии кучи h1 и h2 уничтожаются.

??? Конструктор перемещения.
??? Запрет конструктора копирования.

Оператор присваивания???



Деструктор
----------
???


Итераторы
---------
begin
end
Для типа предусмотрен random access iterator


Размер
------
empty
size


Изменения
---------
bool insert(T value)
bool absorb(&BinomialHeap child_heap)
*: bool absorb_copy(&BinomialHeap child_heap)
bool pop_top()
bool erase(BinomialHeap::iterator)
&T top()
*: const &T top() const 
void clear()


так блин, закожу ли я это когда-нибудь???
=========================================

Класс ValHolder (объявление, конструктор)
Тест конструктора

Класс ValPointer 
Тест конструктора

Класс BinTree
  Конструкторы, тест конструктора
  Метод eat, тесты метода eat (), проверка инварианта размеров

  Метод clear(), тесты на memory leak

  Функция rehang (в классе BinTreeFunctions)
    !Тесты rehang!!!, тесты rehang с eat

  Метод is_son() + Тесты + тест на скорость

  Метод lift() + Teсты + тест на скорость

  Функция merge (от компаратора, в классе BinTreeFunctions)
    тесты merge (+ тест на инвариант)

  Функция CutRoot (в классе BinTreeFunctions)
    тесты cutRoot + ещё один тест на утечки памяти

Поразвлекаться с private, friend и так далее.
Поразвлекаться с const.
Поразвлекаться с try catch.

Тесты разных типов

Генерация кучи необходимой высоты

Класс BinHeap
    Конструкторы, тесты конструкторов
    Простые операции типа size, empty

    insert_bin_tree()
    проверка структуры
    insert()
    Тест на инварианты pointerа, проверка стуктуры, проверка скорости
    insert_list()
    eat()
    Всё те же тесты, как к insert, +проверка операций size, empty
    find_tree()
    Тесты на всякие случаи
    Операция erase - инварианты, память
    Операция clear — память
    Поиск top, удаление top

Интегрейшн:

Огромный тест тупо засечь время

Огромный тест, с проверкой инвариантов
  +кучесть
  +размеры (размеры деревьев, и размеры детей деревьев)
  +утечки памяти

Тесты на использование кучи как кучи (поискать на информатиксе задачи на кучи, дейкстра с кучей, сортировка кучей, ближайшие к данной точки (тест на состояние компаратора))

Сравнение кучи с медленным аналогом (проверка top и т. п.)

Тесты на слияние: генерация куч необходимой высоты, слияние, потом расфигачивание этого списка, добавление некоторого количества вновь сгенерированных, снова слияние

Тест добавление элемента

Тест удаление элемента

Тест удаление/добавление элемента

Тесты на утечки памяти с clear()

утащить к себе http://informatics.mccme.ru/moodle/mod/statements/view.php?chapterid=755