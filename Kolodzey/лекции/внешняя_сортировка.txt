==Внешняя сортировка==
срок сдачи: 21.10.2013

0) Дан файл ≈ 1 TB

1) Считать части по N GB
2) Отсортировать каждую часть в памяти
3) Записать части на диск
4) Объединяем части
    4.1) Считывание
    4.2) Алгоритм объединения

 //стандартный sort(Begit, End, Comparator) — сортирует любые типы
 //Внутри: qsort, heapsort, insertion sort


Нам нужно:
-*как сортировать? (sort и цифровая)
-как сливать?
-*как читать (текстовый и бинарный)
-*как писать промежуточное (текстовый и бинарный)
-*как выводить (текстовый и бинарный)
^
| задача пользователя, реализовать нам компаратор, выбрать типы чтения и записи


//Основные задачи общего алгоритма:
//-Воспользоваться проще, чем написать самому заново


==Гарантированно сделать к 21.10.2013==
T = int
формат файла text
сортировка частей std::sort
=======================================


//функция работает за O(cумма длин векторов, ибо объекты копируются)
bool cmp(vector<int> a, vector<int> b) {
	return a[0] < b[0];
}
//функция работает за O(1), объекты не копируются и не изменяемы
bool cmp(const vector<int> & a, const vector<int> & b) {
	return a[0] < b[0];
}

Возможно преобразование типа в константный, а обратно нельзя
const_cast <T&> (a) — возвращает неконстатную ссылку, так делать ОПАСНО



В структуре и в классе могут быть поля, 
В структуре и в классе можно объявлять некоторые функции (т. е. методы)
метод можно сделать константным, тогда хранимые поля станут константными, а аргументы останутся, как были
Если в функцию передают константную ссылку на объект, то у объекта можно использовать только константые методы

//внутри public
//используют для хранения данных
//данные + простые методы
struct A {

//поля описывают в конце, перед точкой с запятой	
};




//внутри private
class A {

public:
...
//публичные поля в классе объявлять не принято

private:
...	

};




//у vector есть два оператора [], константный и неконстантый
[]const -> const T& //для константного вектора
[] -> T& //для обычного
У обычного просто так не получится вызвать константый метод, самый простой способ
vector<T> a;
const vector<T> &b = a;
b[0];


const T& operator [] (const int idt) const {
	
}

const T& - тип возвр. значения
operator [] - название оператора
(const int idt) - аргументы
const - не изменять поля структуры, чей метод

//переопределить [] для нескольких аргументов :)
//Хороший интерфейс — интерфейс, которым нельзя воспользоваться неправильно



==пример класса==
class Element {
	public:
	    Element(const vector <int> &a, int idx)
	        :a(a),
	        idx(idx) {}
	int value() const {
	    return a[idx];
	}
	private:
	    const vector <int> &a; //ссылка на массив, чтобы его не менять
	    int idx;
}

//перед копируемыми объектами const менять не принято; т. е. писать const без ссылки, ибо с копией делайте, что хотите
//внутри класса методы можно объявлять в любом порядке, никакой проблемы с рекурсией

//конструктор из одного элемента
struct A{
	A(int x)
	{

	}
};
Можно вызвать спецэффект A a = 15;
f(const A & a)
f(15) — сконвертируется и сконструируется

Чтоб убить неявное преобразование
struct A{
	explicit A(int x)
	{

	}
};

Если хочешь написать неявное преобразование
//оправдание
/*implicit*/