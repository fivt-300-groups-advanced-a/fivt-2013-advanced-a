===Шаблонное программирование===

Полиморфизм без оверхеда, который создают виртуальные функции  (см. пред. конспект)

А ещё бывают шаблоны для класса

template <class T>
class Point {
	T x, y;
}

Компилятору всё равно, пишите хоть Point<Point<Point<int>>> :)
//сначала создатся Point<int>, пот от него Point<Point<int>>…

=Специализировать шаблонные классы=

Ну вот типа есть у нас шаблонный класс

template <class T>
class Point {
	T x() const {return x_};
	T x() const {return x_};
	private:
	T x_, y_;
};

Ну и вдруг нам надо хранить два boolean. Давайте специализируем класс, для этого

template <> //вообще в угловых скобках оставшиеся свободными параметры
class Point <bool> {
	//Внутри нужно всё полностью заново написат
	bool x() const {return x%2 == 1;}
	private:
	    char coords_;
}

template <class X> //вообще в угловых скобках оставшиеся свободными параметры
class Point <vector<X>> {
	…
}
Степень специализации определять по объявлению класса Point


Пример использования шаблона = vector<bool>

Вектор bool устроен по-другому, там биты хранятся в жатом виде
Поэтому, т. к. ссылок на бит не бывает, он возвращает вот такую структуру при запросе ссылки
(ну то бишь неконстантного метода)

BitRef {
	int ref_;
	int offset;
}

BitRef operator[] (int idx) {…}
bool operator[] (int idx) const {…}


Дальше больше — специализация для набора типов
const T& operator [] (…) const {}
Вот например, зачем возвращать конст. ссылку на int, если можно вернуть нормальный int?
const_ref<T>::type operator [] (…) const {}

const_ref<T>::type - метафункция, принимает на вход тип и возращает тип (ну на самом-то деле структура с typedef)

//мб эта штука называется по-другому
template <class T> //стандартное объявление const_ref как в namespace std
struct const_ref {
	typedef const t& type;
}

template<> //поэтому можно свою структуру узкоспециализировать, внутри namespace std
struct const_ref <int> {
	typedef int type;
}


//кстати, узкая специализация = пожалуй, единственное, что можно делать в namespace std

А давайте теперь поговорим о том, что можно переопределять в std
t<class T>
void swap(T&a, T&b) {
	T x = a;
	a = b;
	b = x;
}
Но для векоторов переопределено
a.swap(b); Шоб не было лишнего копирования
Собственно, для своего класса тоже можно что-то такое переопределить

Вернёмся к метафункциям
template <class T>
struct is_fundamental{
    static const bool value = false;
    //static - не принадлежит экземпляру класса, а общая на всех
	
}
is_fundamental::value - обращение к статической переменной

Кстати, в метафункциях можно использовать другие функции, которые можно вычислить на этапе компиляции

Параметры шаблонной программы: либо целое число, либо тип
t<int X> class F {};
F<15>

constexpr = функции, вычислимые на этапе компиляции (нельзя сложные типы, многобукафб циклы)
constexpr int factorial(int x) {
	return x==0?1:x*factorial(x - 1);
}

Повесить компилятор стало проще :P
factorial(factorial(15)) :)

А ещё бывают constexpr class Point {
	constexpr Point (int x, int y) :x(x), y(y) {
	}
}

//класс constexpr и методы constexpr
//и вощем такой класс можно constexpr функциям передавать
//главное не constexpr методы не вызывать


//summary
//как узко специализировать
//мета-функции
//constexpr


Так, а теперь для пишем штуку, которая целые числа сортирует цифровой сортировкой, а нецелые - обычной

template <class T>
class UsualSort {
	template <class Cmp> //никто не мешает делать шаблонные методы внутри класса :)
	void sort (<vector <T> *, Cmp cmp) {
		std::sort(v->begin(), v->end(), cmp);
	}
}

//сначала объявили шаблон struct, причём можно и не реализовывать
template <class T, boolIsNumeric>
struct OSHelper;

template <class T>
struct OSHelper <T, false> {
	typedef UsualSort <T> type;	
};

template <class T>
struct OSHelper <T, true> {
	typedef DigitalSort <T> type;	
};


template <class T>
void OptimalSort(vector <T> *v){
	OSHelper <T,is_integral<T>::value>::type sorter;
	sorter.sort(v, cmp); //можно передавать всегда компаратор,
	//т. е. одинаковый интерфейс у классов UsualSort и DigitalSort
}

А ещё можно предопределять default (причём шаблоном :)
template <class T, class Reader = DefaultReader<T>::type>
//Пример = map <K, V, cmp = std::less>

//Ещё пример - определение типа переменной, в которую указывает итератор
//кстати, шаблон, можно и для своего типа определить
iterator_traits <It>::value_type tmp = *b;
//в принципе, в каком-нибудь векторе можно написать vector::type, но с нормальными ссылками такое не прокатит

typename A::value - ну потому что :: можно и к перменной обратиться, а typename говорит компилятору, что это тип

А ещё есть такая штука auto.
auto tmp = *b
Вычисляет тип по правой части