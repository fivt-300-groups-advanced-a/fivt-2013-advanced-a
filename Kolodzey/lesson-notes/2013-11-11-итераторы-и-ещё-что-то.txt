11.11.13

Давайте обсудим способы хранения.

Если вы пишете левую кучу, то вам нужно хранить указатели на предка, на левого и на правого ребёнка.

Если у вас биномиальная куча, то можно детей и в векторе хранить.

Если у вас фибоначчева куча, то нужен список. //Надеюсь, никто не пишет фибоначчеву кучу.



А теперь давайте поговорим, как устроены стандартные стуктуры и как они решают свои проблемы.

Ряд стандартных структур полезно знать.

vector
map
set
multimap
multiset

unordered set, unordered map - из нового стандарта

У всех этих штук есть ::iterator - класс, который указывает на элемент контейнера. Что внутри --- неясно. Но с помощью этой штуки можно обращаться к элементам.

Что нужно знать об итераторах?
Они бывают разного типа.

forwardIterator
---------------------
it++
++it
*it
Т. е. разыменовывание и увеличение (по интерфейсу совпадает с указателем)


Random access iterator
----------------------------------
Могут перемещаться по структуре сколь угодно хаотично по структуре (например, у std::array, std::vector)
it+=100;
it--;

std::sort хочет два random-access итератора.

it1-it2 = расстояние между указателями


Bidirectional iterator 
-----------------------------
Умеет ++ и --, но, скажем, вычитать их друг из друга нельзя

В мультисете, мультимэпе и т. п.


Что ещё полезного про итераторы?


Ивалидация итераторов и указателей
---------------------------------------------------------

Ну, напермер было у вас два указателя на одну область памяти, потом по одному из них удалили кусок памяти, и второй начал указывать в никуда :( Или не туда :)


Итератор --- это указатель внутрь структуры.

В векторе - указатель на середину вектора. Почему не индекс?
Ну тогда бы пришлось делать дольше - прибавлять, разыменовывать...

Кстати, если вам нужно делать два разыменования для доступа к памяти, то вы плохо задизайнили структуру данных.

У вектора забавная специфика: если вектор переезжает в новую область памяти, то итератор инвалидируется.
Ну и конечно, если вы удаляете элемент, то итератор на него инвалидируется. Кстати, бедный итератор не знает о том, что его инвалидировали.

Нужно считать, что после любого push_back и pop_back итераторы инвалидируются.

Классическая ошибка, которую сложно искать.

class A
{
int f(){
    a.push_back(a.size())
    return a.size();
}
int g(){
    a[0] = f();
}
private:
    vector<int> a;
};

a[0] (ссылка на начало массива) может быть вычислено до вычисления f(), поэтому всё плохо.

Не нужно возвращать ссылки на середину своего объекта.

Если бы у вектора не было оператора [], то c++ был бы явой.


Давайте посмотрим map и set. В них итераторы всегда валидные, кроме случая удаления.

s.insert(7) --- возвращает пару bool и it --- удалось ли вставить новый, и итератор на вставленный элемент.
s.find() либо it на найденное, либо it на end

У set-a s.end() всегда одинаковый.

set.erase(удаление по значению) возвращает bool.
s.erase(по итератору)
Разные штуки в multisete - в одном случае удалит все элементы с таким значением, либо конкретный элемент


Давайте напишем функцию f() которая вычисляет число фибонначи с кэшированием

map <int,int> cache;
int f (int n)
{
    it -> cache.insert(makepair(n,0))
    if (it ->first != 0)
        return it->second;
    return it->second = f(n - 2) + f(n-1);
}

 Способ обойти дерево: идти вверх, пока мы правый ребёнок, один раз наверх, когда мы левый. Если есть правый сын, то от него налево до конца.

Но это если мы хранили предка. А если не хранили, итератор хранил весь стек погружения к вершине. Такое встречается в персистетных деревьях (потому что наверху ничего не меняется)

//вот этот код немного кривоват… :)
class Aiterator {
}

A {
typedef iterator;
}

тайпдеф внутри итератора
v<i>::it::it_tag;

struct RandomAccessIterator{}
VI::value_type;

struct BH{
vector<BT*> roots;
}

В целом, идя в том, чтобы, сделать ValueReference и Отдельно дерево.
И поддерживать, чтобы ValueReference указывало на вершину дерева, в которой оно хранится.	


Стресстесты с оператором командной строки.

Передали владение в функцию и функция его сожрала.
Нехорошо передавать в fill(unique_ptr)