Ошибки, которые я поняла не так
===============================

explicit — запрещает неявное конвертирование вашего класса, пишется перед конструктором

f(Apple a);

Если вы написали Explicit, то не сможете вызвать f(12);
Надо будет писать f(Apple(12));

***

Нельзя делать ссылки на переменные на стеке, не передавайте по значению то, на что хотите делать ссылку.

***

Не пользуйтесь этим, но: константная ссылка на временный объект точно будет жить до конца оператора (видимо, до ближайшей точки останова?)

***

Абстрактный класс — класс, у которого есть хотя бы один нереализованный метод.

Объявление абстрактного метода.
virtual int x() = 0;
Зачем тут = 0? чтобы компилятор не упал при линковке, в поисках реализации.

***

Ещё раз о пользе виртуальных деструкторов.

Обязуюсь не удалять по указателю на предка, если у предка нет виртуального деструктора.

Собственно, бага с памятью возникнет если вы удалите объект по ссылке на предка, а деструктор не виртуален, ну и поля наследника не удалятся.

Зачем же тогда заморачиваться со ссылками на предка? Собственно, ссылками на предка реализуется полиморфизм через наследование.

***

Возвращаемый тип — это не сигнатура функции.
Константность — это сигнатура функции (естессно, не имеется в виду константность возвращаемого значения)
Аргументы — это сигнатура функции.

//что-то про системы версий, философия на тему, что лучше: ветки или линейность


А теперь, новое задание
=======================

Чо писать
---------
Дерево отрезков

Дедлайн
-------
конец семестра

Произвольный тип, который хранится в вершине
update(l,r, G)
get(l,r, F)

Параметры: tip, набор операций в update, набор операций в get()

Ну ок, начнём с такой общей штуки
AdvancedSegmentTree<ReturnType, MetaInformationUpdate,push,merge,union>

Собственно, идея в том, чтобы свалить всё на пользователя, а дерево реализовать в общем виде.

/*вот тут я втыкала в доску и ничего не писала*/

А потом написать несколько специализаций.

Короче, это всё детали реализации, а вот ТЗ:
--------------------------------------------
(2)I. Написать деревья минимума максимума суммы
1. с операциями +;
2. присвоить;
3. + и присвоить

(3)II. Тесты
1. stresstest (сравнение с тупой структурой)
2. ручные тесты (такие, маленькие и сложные)
3. тесты внутренней структуры (считать вызовы, свой пуш мёрж и юнион, который проверяет, сколько и откуда всё вызвалось)

(0.5 + 2)III. Количество уникальных элементов на отрезке + test
set(idx, b) присвоение по индексу UPD =заменено на отрезок максимальной суммы=

(0.5 + 2)IV. Количество отрезков постоянности на отрезке + test
прибавить
присвоить (всё на отрезке, конечно же)

