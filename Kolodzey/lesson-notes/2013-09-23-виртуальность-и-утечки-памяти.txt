заметки 23.09.2013

Ещё чуть-чуть о работе языка c++

Си-функции чтения:
scanf ("%d", &x)

Считывает из stdin и принимает на вход формат, куда надо считать.
scanf — читает сишную строку.
Сишная строка — последовательность любых байтов, в конце которой стоит символ 0. В частности, из-за этого в строке не может быть символа 0 посередине.
Память для строки нужно выделить, иначе она считается в мусор.

char buffer[1000];
fscanf(f, "%s", buffer);

fscanf считает последовательность символов до пробела, в конец дописывает символ \0
Если buffer меньше, чем длина строки, fscanf всё равно считает строку подряд, забив память после выделенной для buffer. И вообще можно буфер нафиг переполнить.

В общем, пользоваться сишными строками небезопасно, используйте строки c++.

//include "stdio.h" — сначала ищет в текущей директории
//include <stdio.h> - ищет в стандартной библиотеке
//Правильней подключать си-библиотеки используя название <cstdio>, они адаптированы для c++
//чаще всего cstdio запихивает c-функции в namespace std
//namespace нужно для убивания конфликта одинаковых имён

std::string s;
внутри — сишная строка и её размер.

//Чтобы определить длину сишной строки, нужно линейное время
//т. к. strlen тупо шёл до конца строки
//for (i = 0; i < strlen(s); ++i) = работает за квадрат.

std::cin >> s;
Считывает символы, если массив слишком маленький, то его нужно расширить. Умно и динамически :)

Чуть больше проблем про переполнение буфера.
Пусть есть void f(int a, int b);
Пусть вы её вызвали f(a, b);
В стеке хранится вся информация о вызываемых функциях, стек заполняется справа налево.
Что записывается в стек?
1. Адрес возврата.
//Чойта? Ну вся программа лежит в оперативке, и поэтому нужно записать из какого блока оперативки вызвали функцию, чтобы функция вернулась обратно 
2. Аргументы функции.
Ну и функция говорит a = gettop, b = gettop и удаляет их из стека.

Локальные перменные тоже выделяются на стеке. Поэтому если вы переполнили локальную перменную, то вы можете поломать адрес возврата, и вообще вернуться в другую программу.

Ну, если вы хакер, то вы можете этим пользоваться :)

Не пользуйтесь функциями си, которые используют буфер, ну или указывайте им, сколько нужно считать
fread() //ей указывается, сколько нужно считать

sizeof(T) — указывает, сколько байт занимает переменная типа T
fread(buffer, sizeof(T), 1, infile)

reinterpref_cast<T*>(b) — мне не важно, какого типа b, скажи, что теперь оно типа T
кастуем указатель на b к указателю на T

в fread можно передать указатель на перменную, ну и читать прямо туда в бинарном виде. freadу абсолютно всё равно, что из себя представляет область памяти, куда он читает

В c++ есть вариант объявить ifstream, а у него функция read(&x, sizeof(T));


==Наследование==

class A {
  public:
	int f();
	int g();
};

class B:public A {
	//все public методы B стали методами B
	//все приватные методы остаются внутри A (ну то есть из B их не вызвать)
	//класс B хранит состояние своего предка + новое состояние класса B
	//всё, что записано в protected может вызываться в потомках при публичном наследовании

	//Если мы в классе B объявим свою f, то она перекроет функцию класса предка,
	//Не надо так делать
}

Наследование = меньше кода

Если у нас нормальное линейное наследование, то объект занимает ровно памяти под все переменные, а функции нормально вызываются

Инкапсуляция = скрывать детали реализации в объекты или функции


=Полиморфизм=

class A {
	virtual void say() = 0; //=0 абстрактный метод, который нужно реализовать в потомке
	//если абстрактный метод не реализован, то компилятор ругнётся при вызове конструктора класса
}

//virtual - потомки могут переопределить этот метод

class Cat: public A {
	//override — проверяет, что у предка есть такой метод, и что он виртуальный
	override void say()
}

class Bear: public A {
	
}

say3times(Animal* a) {
	a->say();
	a->say();
	a->say();
}

Cat c;
c.say();
say3times(&c);
Animal — абстрактный класс, на него можно делать указатель.
В вызове функций классы спокойно кастуется к предку, но прямо преобразовать не получится, но зато можно спокойно преобразовывать указатели

Как только вы в каком-то классе пишете virtual, вы заключаете сделку с дьяволом.
У него появляется RTTI = runtime type information
Поэтому у всех наследников абстрактного класса есть ссылка на таблицу виртуальных функций.
рассмотрим метод say в классе Animal
say()
{
	иди в таблицу виртуальных функций
	иди выполнять код, который соответствует этой функции
}
А без виртуальных ф-ий у вас нет этого лишнего шага.
Преимущество — полиморфизм.
Пример полиморфизма istream, ostream


==Полиморфизм через шаблоны==
Полиморфизм = в функцию вы можете передать любого наследника определённого класса
Шаблоны = можно передать любой объект, лишь бы тело ф-ии скомпилировалось

Плюсы шаблонов — не надо вызывать через виртуальные функции, функции компилируются каждая заново и оптимизируется по-отдельности; больше власти компилятору!

Вообще в стандартной библиотеке очень много вызовов туда-сюда, которые компилятору нужно схлопывать. Но virtual закрывает для компилятора возможность красиво схлопнуть функцию, потому что ему приходится ожидать подставы.

sort(b, e, cmp) — шаблонная функция.
Если в качестве компаратора передавать функцию, то компилятор не сможет заглянуть внутрь неё и соптимизировать, для всех вызовов с функцией один байт-код, потому что у всех функций одинаковый тип — указатель на функцию
А если писать функтор, то они будут иметь разные типы и поэтому компилятор каждую штуку скомпилирует в отдельный байт-код и соптимизирует


class A {
	virtual f();
	virtual ~A(){

	} //виртуальный декструктор. Обязательно пиши, если есть виртуальный метод!
}

Animal* a = new Dog(); //создаётся в куче, будет жить, пока вы явно не скажете delete a

Dog d; //создаётся на стеке, и в конце области видимости у d будет вызван деструктор

delete a; <=> a.~Animal()
Если деструктор не виртуален, то не удаляться поля, которые надо бы удалить из Dog


==Тестирование==
googletest

#include "gtest/gtest.h"

TEST (Название группы тестов, название теста)
{
	int sum = 2 + 2;
	EXPECT_EQ(4, sum); //если условие не выполнено, тогда потом расскажет об ошибке
	ASSERT_EQ(4, sum); //если условие не выполнено, тогда программа выйдет
}

нужно освоить тесты за эту неделю