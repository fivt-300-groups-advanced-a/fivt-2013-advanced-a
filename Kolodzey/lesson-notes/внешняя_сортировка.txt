==Внешняя сортировка==
срок сдачи: 21.10.2013

0) Дан файл ≈ 1 TB

1) Считать части по N GB
2) Отсортировать каждую часть в памяти
3) Записать части на диск
4) Объединяем части
    4.1) Считывание
    4.2) Алгоритм объединения

 //стандартный sort(Begit, End, Comparator) — сортирует любые типы
 //Внутри: qsort, heapsort, insertion sort


Нам нужно:
-*как сортировать? (sort и цифровая)
-как сливать?
-*как читать (текстовый и бинарный)
-*как писать промежуточное (текстовый и бинарный)
-*как выводить (текстовый и бинарный)
^
| задача пользователя, реализовать нам компаратор, выбрать типы чтения и записи


//Основные задачи общего алгоритма:
//-Воспользоваться проще, чем написать самому заново


==Гарантированно сделать к 21.10.2013==
T = int
формат файла text
сортировка частей std::sort
=======================================


//функция работает за O(cумма длин векторов, ибо объекты копируются)
bool cmp(vector<int> a, vector<int> b) {
	return a[0] < b[0];
}
//функция работает за O(1), объекты не копируются и не изменяемы
bool cmp(const vector<int> & a, const vector<int> & b) {
	return a[0] < b[0];
}

Возможно преобразование типа в константный, а обратно нельзя
const_cast <T&> (a) — возвращает неконстатную ссылку, так делать ОПАСНО



В структуре и в классе могут быть поля, 
В структуре и в классе можно объявлять некоторые функции (т. е. методы)
метод можно сделать константным, тогда хранимые поля станут константными, а аргументы останутся, как были
Если в функцию передают константную ссылку на объект, то у объекта можно использовать только константые методы

//внутри public
//используют для хранения данных
//данные + простые методы
struct A {

//поля описывают в конце, перед точкой с запятой	
};




//внутри private
class A {

public:
...
//публичные поля в классе объявлять не принято

private:
...	

};




//у vector есть два оператора [], константный и неконстантый
[]const -> const T& //для константного вектора
[] -> T& //для обычного
У обычного просто так не получится вызвать константый метод, самый простой способ
vector<T> a;
const vector<T> &b = a;
b[0];


const T& operator [] (const int idt) const {
	
}

const T& - тип возвр. значения
operator [] - название оператора
(const int idt) - аргументы
const - не изменять поля структуры, чей метод

//переопределить [] для нескольких аргументов :)
//Хороший интерфейс — интерфейс, которым нельзя воспользоваться неправильно



==пример класса==
class Element {
	public:
	    Element(const vector <int> &a, int idx)
	        :a(a),
	        idx(idx) {}
	int value() const {
	    return a[idx];
	}
	private:
	    const vector <int> &a; //ссылка на массив, чтобы его не менять
	    int idx;
}

//перед копируемыми объектами const менять не принято; т. е. писать const без ссылки, ибо с копией делайте, что хотите
//внутри класса методы можно объявлять в любом порядке, никакой проблемы с рекурсией

//конструктор из одного элемента
struct A{
	A(int x)
	{

	}
};
Можно вызвать спецэффект A a = 15;
f(const A & a)
f(15) — сконвертируется и сконструируется

Чтоб убить неявное преобразование
struct A{
	explicit A(int x)
	{

	}
};

Если хочешь написать неявное преобразование
//оправдание
/*implicit*/




///////==///////
include <iostream>
include <fsream>
sync_with_stdio(false); //отключить синхронизацию буферов для cin и scanf
std::cin >> x >> t;

ifstream in::("o.txt");
in >> x >> z;
Для красоты можно переопределить оператор <<
(cout << 5) —> ostream, поэтому можно дальше выводить

//всё передавать по ссылке
istream& operator >> (istream& in, T& t) {
	return (in >> t.x >> t.y);
}

sort (a.begin(), a.end(), Cmp())
//последний параметр — созданный объект, у которого есть круглые скобки

struct Cmp {
	bool operator() (int x, int y) const
	{
	    return x > y;
	}
};

//greater<int>();
//стандартный less возвращает a < b; можно переопределить оператор <;


"std::less"

READER
"std::read" >>


struct Reader {
	int operator () ()  //функтор; круглые скобки очень удобно, когда хочется иметь возможность передавать скобки
	//ну можно и метод next или read
}

sort (Reader r, ……………………)
{
	<T> t = r();
}


====Шаблонная сортировка пузырьком=====

template <class Iterator, class Comparator>//описываем, что типы Iterator и Comparator — динамические

void sort (Iterator b, Iterator e, Comparator cmp = std::less[typeof(*b)])
{
	for (Iterator i = b; i != e; ++i)
	{
		for (Iterator j = i; j !=e, ++j)
		    if(cmp(*j,*i))
		    {
		    	swap(*i, *j);
		    }
	}
}
//можно написать template <typename Iterator>, вообще без разницы, только в стилистике

======

 компилятор будет создавать отдельные функции для всех необходимых типов и оптимизировать их по отдельгности

//iterator traits


template <class T>

struct less {
	bool operator() (const T& a, const T& b) const {
	    return a < b;
	}
}

//const_ref <T>::type - возвращает значение для примитивных типов и ссылку для более сложных


23092013
Ещё раз:
Нужно уметь менять чтение, вывод и ввод во временные файлы, вывод в конечный файл
Нужно уметь менять виды сортировки в памяти
Нужен компаратор (особенно, чтобы объединять блоки)
Нужно как-то поддерживать размер блока (ну то сколько памяти мы можем скормить программе)

//implace merge sort = stable sort за n (log n)^2

30092013
reader стандартный >>

memory = количество байт, которое можно выделить.
size_t = хороший тип для передачи этого аргумента
потому что теперь память может быть меньше int-а

Ну собственно передать аргументом желаемое количество используемой памяти

sorter (vector<T> * V, cmp)

тепереча про цифровую сортировку:
от объекта получать кол-во цифр и i-ую цифру
Поэтому нужен класс, который разбивает объект на цифры BitExtractor
numDigit(T)
digit(T, indx)
ну и интервал, в котором есть наши значения
а примитивные типы по 2 байта :)