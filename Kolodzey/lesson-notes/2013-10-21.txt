Как работают stl-контейнеры? Они хранят некоторый тип t.

T должен быть copiable //старый стандарт
ну или moveable //новый стандарт

По умолчанию все объекты формально копируемые - конструктор копирования. Но, понятно, что не всё так просто, и если вы, например, указатели храните…

Ну и вектор потоков ввода — это тяжело…

В общем, сложные классы лучше делать некопируемыми

Кладите в контейнер unique_ptr  (он не копируемый, но в вектор класть можно. Потому что он мувеабл)

Вызывает конструктор перемещения A&&
Тип t считается перемещаемым, если у него есть дефолтное состояние и конструктор перемещения T(x), который создаёт полную копию объекта x, а x переводит в дефолтное состояние (дефолтное = что-то типа указателя на null)


Объединяемая куча
=================

I куча + integration test
-------------------------
сравниваем с медленным аналогом

II модульное тестирование
-------------------------
генерировать кучи разного вида и проверять работу операций
Чёткий контроль за кучей!!!

III проверка инвариантов стресс-тестами
---------------------------------------
инварианты: это куча, она левая, проверять, что это выполнено

IV поддержка произвольного типа, тестирование разных типов
----------------------------------------------------------
тестирование своего типа

V операции decrease_key, удаление произвольного элемента
--------------------------------------------------------

Дедлайн = 25.11.2013

Грубо говоря, интегрейшн тесту всё равно, что в куче, можно один на разные кучи делать


std::less — компаратор без состояния
а можно сделать компаратор с состоянием, типа расстояние от заданной точки



Мини-контрольная
================

На следующей неделе будут перечислены типичные ошибки.

На контрольной будет выдана программа, с кучей ошибок, нужно будет пояснить, как не стоит делать