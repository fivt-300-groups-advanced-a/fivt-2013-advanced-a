заметки 07.10.2013: Как устроена сборка языка c++
=================================================

Элементарная команда сборки файла
g++ <флаги> a.cpp
-O2 = оптимизация второго уровня 
-o = имя бинарника

Собственно, как компилятор собирает прогу:

1. Парсит исходники

1.1 Заменяет include на соответствующий текст из файла в скобках
    Рекомендуется ваши файлы инклудить в ""
    А системные в <>

1.2 Препроцессинг (разворачивание #define и прочих макросов)
    тупо заменяет одно на другое
    бывает ещё и #define с параметрами
    #define abs(x) (x) < 0 ? -(x): (x)
    Не забывайте писать скобки вокруг X, чоб не было 5 - 3 < 0 ? -5 -3: 5 - 3

    Сейчас макросы не используются, вместо них функции и шаблоны
    Раньше просто templatов не было
    Ну и вообще, сейчас компиляторы хорошо инлайнят функции, незачем делать это макросами
    Ну и там представь, что при тупой подстановке значения будут считаться много раз. И бывает бага, что из-за этого функция из линейной станет экспоненциальной.

2. Компиляция кода

2.1 Берём все функции, кроме шаблонных и inline, компилируем отдельно и независимо.
    Получаем byte-код. Она настолько независима, что даже можно вызвать её из ассемблера. И да, call f положит f в стек вызова, и перейдёт на начало её байт-кода
    Каждый cpp файл переходит в .o (object-file). По сути, object-file - это map (ассоциативный массив) из названий функций в byte-код (имена переменных тоже входят в название, ибо перегрузка функций)
    
    У нормальной программы должна быть одна функция main(int argc, char** argv)
    Запуск программы ./f 15 13 вызовет main с параметрами
    argc = 3
    argv[0] = "./f"
    argv[1] = "15"
    argv[2] = "13"

    Методы класса тоже превращаются в функции

3. Линковка
3.1 Мы получили не такие уж исполняемые бинарники, потому что только во время
	линковки мы узнаем про все функции. call f нужно заменить на ссылки в нужное место бинарника. Именно это и делает линковщик: собирает .o в один большой файл, заменяет вызовы функций на прыжки по адресам, ну и там в стек кладёт адреса возврата.


Компилятору при сборке необязательно знать реализацию функции, достаточно знать, что она есть. Все проблемы по поиску реализации функции решает линковщик.

Обычно в проектах разделяют объявления и реализацию. Объявления пишут в .h файлах, а реализацию в .ccp файлах. cpp файлы обычно не инклюдят.

Пример.
a.h
	int f(int x) {return x;}
b.cpp
	#include "a.h"
c.cpp
	#include "a.h"
g++ b.cpp c.cpp
Компилятор ругнётся, ибо f(x) реализована 2 раза.

Есть 2 способа преодолеть такую багу.

Способ 1: в .h только объявить, а реализовать 1 раз.
----------------------------------------------------
a.h
	int f(int x);
b.cpp
	#include "a.h"
	int f(int x) {return x;}
c.cpp
	#include "a.h"

Правда, можно получить ошибку, когда у нас ссылка в никуда
Пример:
a.h
	int f(int x);
b.cpp
	#include "a.h"
	int f(int x) {return x;}
c.cpp
	#include "a.h"
	g(int x)
	{
		return f(x);
	}

Если попытаться собрать c.cpp сам по себе, то исполняемый файл не получится, т. к. f(x) --- непонятно что. Поэтому обязательно собирать вместе с b.o

Если вы объявляете класс, то нужно объявить все методы и все поля. Все поля нужны для правильного выделения памяти.

Если ваш код лежит в разных файлах, то компилятору сложнее оптимизировать, в частности, не вставить inline из другого файла.

На самом деле, в h файле можно реализовывать inline функции и templates, ибо для них не создаётся байт-код на этапе компиляции, а значит не будет конфликта, что ф-ия несколько раз реализована.

Кстати, шаблоны НАДО писать в h файле, потому что для компиляции шаблонной ф-ии необходимо знать её реализацию.

У классов функции по умолчанию inline

Кстати, можно не инклюдить заголовочные файлы целиком, а просто объявлять нужные классы.

Inline = "Товарищ компилятор! Заинлайнь вот это вот, по-возможности. И, ПОЖАЛУЙСТА, не генерируй публичный байт-код"
Поэтому inline замедляет компиляцию, ибо функция компилируется в каждом cpp файле.
Если в вашем проекте миллион файлов, использующих vector, то vector будет скомпилирован 1000000 раз.
Ну и ещё inline раздувает объектный код. Большой код —-- это плохо, по памяти прыгать неудобно (особенно по разным страницам оперативки)
Но компилятор обычно следит за размером ф-ии.

Ну и когда вы собрали программу из нескольких файлов, должна быть одна ф-ия main, она --- точка входа.

Это всё было про статическую сборку stand-alone проекта.

А теперь про динамическую сборку
LOAD_LIB("z.lib")
Библиотека --- это несколько заголовочных файлов и собранный байт-код
zip.h
unzip.h

g++ a.cpp -l zlib теперь можно ф-ии искать в библиотеке

Плюс = если две программы одновременно используют библиотеку, то библиотека загружается 1 раз.

В виндовс dll, .so

А ещё есть .a == статическая библиотека, она загружается в вызываемый exe. Приятная независимость + нет перекомпиляции. .a == удобно для распространения, потому что надеяться на стандарные dll не всегда можно.

А ещё линковщику совсем не важно, какую .so вы ему подсунули
Даёшь кроссплатформенность!

Все вспомогательные ф-ии генерировать в анонимном namespace
Более old-school вариант (уже не модно) можно было делать static функции