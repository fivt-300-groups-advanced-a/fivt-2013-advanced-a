Продолжаем про хеш-функции.

Пусть есть строка длины N, считаем количество различных подстрок строки.
Можно считать хеш от подстрок и помещать хеши в хеш-таблицу. Это можно делать за O(N^2)
Пусть хеш-функция имеет равномерное распределение, то есть для K значений она на произвольной строке выдаст то или иное значение 1/K раз.
Тогда вероятность коллизии на M экспериментах равно. A(k,m)/k^m
Короче, вероятность того, что какие-то значения совпадут почти 0.

Давайте рассматривать не все строки подряд, а строки по длинам. То есть отдельно посчитаем для строк длины 1, строк длины 2 и т.д.
Тогда вероятность коллиции - это MULT(i)(A(k,n-i)/(k^(n-i)))
Она значительно ниже. 
При K=2^64, N=10^4
В первом случае вероятность успеха: 0.9997289859262442
Во втором случае: 0.9999999910605156
^ (c) Python 3.4

Будем считать, что хеш-функциями мы закончили.

Новая тема.
Процессор. Его кеш. Алгоритмы, связанные с этим.

Сначала жёсткий диск. HDD. До сих пор чтение с жёсткого диска - позиционирование головки и чтение.
Позиционирование головки сейчас в среднем занимает 10-30 мс, что сейчас очень долго.
Скорость чтения подряд-идущих данных сегодня - порядка 200-300 МБ/c

Оперативная память. RAM. Случайный доступ к памяти сейчас происходит за 10^(-4) мс.

Сейчас что-то среднее между HDD и RAM - это SSD.
Время чтения у SSD порядка 10^(-2) мс.
Однако у SSD ограничено число циклов перезаписи.
SSD разделён физически на блоки. При чтении может запрашиваться только блок целиком.
Если нужно изменить бит в каком-то блоке, то SSD говорит, что этот блок не валиден и создаёт новый блок, в который записывает изм. информацию.
Поэтому SSD достаточно быстро изнашивается.
Раньше это были сумасшедшие цифры, вроде 10^4 циклов перезаписи.
Вообще использовался SSD как очень долгий кеш.

Теперь процессор.
У процессора есть кеш, точнее даже 2 кеша
Кеш процессора состоит из кеш-линий - блоков данных. Каждый блок данных ассоциирован с каким-то адресом в оперативной памяти.
При этом блоки работают одновременно - параллельно.
Если вы обращаетесь к какому-то биту оперативной памяти, то с большой долей вероятности в кеш попадёт кусок памяти рядом с этим битом.

Если вы будете суммировать элементы массива последовательно и в случайном порядке, то последовательно - намного быстрее.
cache-hit - когда мы обращаемся к памяти и она в кеше процессора.
cache-miss - когда мы обращаемся к памяти, а она не находится в кеше процессора.
Вообще современные алгоритмы нужно оценивать по количеству кеш-миссов.
