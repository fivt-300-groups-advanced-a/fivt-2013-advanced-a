Начнем этот семестр с темы строки. Строка - массив символов.
Префикс строки - 0 или более символов в начале строки, в том числе вся строка.
Суффикс строки - 0 или более символов в конце строки.
Собственный префикс\суффикс - исключая всю строку.
Подстрока - любая неразрывная последовательность внутри строки.
Самая классическая задача - поиск образца s в тексте t. То есть нужно найти все вхождения данной строки в тексте.
Тривиальное решение - перебор всех позиций, с которых может начинаться образец. Время работы O(|t|*|s|).
В библиотечых решениях чаще всего используют этот алгоритм. В процессор можно поместить слово размером 8 символов. Поэтому можно смело время работы делить на 8.

Префикс-функция
Для строки s префикс-функцией называется длина наибольшего префикса, совпадающего с суффиксом.
abacaba - префикс-функция равна 3.
a....aa (n раз) - префикс-функция равна n-1.
Зачем это нужно? Мы сможем найти подстроку в строке с помощью префикс-функции.
Рассмотрим, например, строку s$t. Посчитаем префикс-функцию для каждого префикса.
Тогда, если в какой-то позиции значение префикс-функции равно длине образца, то образец заканчивается в этой позиции.
Префикс-функцию будем считать для каждого префикса. Будем делать что-то вроде динамического программирования.
p(k) - значение префикс-функции для k-ого префикса - префикса длины k.
Понятно, что p(1) = 0.
Пусть мы знаем p(1), ...., p(i). Хотим найти p(i+1).
Если вышло так, что s[p(i)+1] == s[i+1], то, очевидно, что p(i+1) = p(i) + 1. Просто отбросим последний символ и получим сведение соответсвия к меньшей строке.
Пусть нам не повезло. Будем искать второй по размеру префикс, совпадающий с суффиксом. Это будет p(p(i)). Далее рассматриваем p(p(p(i))) ... и т.д.
Пока не найдём равный символ или получим ответ 0.
Напишем псевдокод алгоритма.
p[1] = 0
q = 0
for l in [2, |s|]:
	while (q > 0 && s[q + 1] != s[l])
		q = p[q]
	p[l] = q + 1 | 0
	q = p[l]
За сколько работает алгоритм?
На первый взгляд время работы O(|s| ^ 2).
Оценим лучше. Будем следить, как в процессе алгоритма меняется q. 
В конце цикла q может увеличиться на единицу не более одного раза, а в цикле while может падать сколько угодно.
Фактически, q - переменная оценки в аромартизационном анализе. Её максимальное значение - |s|, а значит время работы алгоритма O(|s|).
Теперь мы умеем искать подстроку в строке за O(|s| + |t|).

Алгоритм КМП
По сути это то, что описано выше, за исключением подхода хранения.
В алгоритме значение префикс-фукции префиксов строки s сохраняется в памяти. 
Значения префикс-функции строки t вычисляется поточно, не сохраняя для него префикс-функции.

Пусть теперь мы хотим посчитать сколько раз префиксы стоки s встречаются в строке t.
Считаем префикс-функцию. Считаем, сколько раз префикс-функция принимала значение q. Прокидываем значение позже по q, p(q), p(p(q)), ...

s[i] = s[i-1] + c[i] + s[i-1] - хорошая строка для тестирования, строка Грея
Строка и префикс-функция.
abacaba
0010123
Префикс-функция задаёт функциональный граф. Граф при этом ещё и ациклический. Вообще говоря это дерево.

Фабрика палиндромов
Пусть у нас есть строка-образец abac.
Мы хотим найти все вхождения фабрики палиндромов: a, abba, abaaba, abaccaba.
Мы умеем находить все префиксы. 
Давайте ещё найдём вхождения префиксов строки s в перевернутом тексте t - мы найдём вхождения всех перевернутых префиксов строки s.
Нужно теперь эту информацию совместить.
С одной стороны для каждой позиции мы знаем все префиксы, которые в этой позиции заканчиваются. 
С другой стороны мы знаем все перевернутые префиксы, которые в ней начинаются.
Для фиксированной позиции мы знаем q префиксов, которые там заканчиваются, и q' перевернутых префиксов, которые там начинаются начинаются.
Дальше в нашем функциональном графе ищем наименьшего общего предка у q и q'. 
От наименьшего общего предка до корня количество вершин будет соответствовать кол-ву палиндромов.