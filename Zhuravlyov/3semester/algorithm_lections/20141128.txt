Сегодня мы говорим про хеш-функции в строках

Хеш-функция - преобразования объекта в целое число.
Хеш-функция хорошая, если в ней мало коллизий. Если объекты не сильно отличаются, похожие объекты должны быть сильно разные хеш-функции.

Классический хеш для строк - полиноминальная хеш-функция. 
(((s[1]*p+s[2])*p+s[3])*p...)%q - вычисление полиноминального хеша. Обычно p - небольшое простое, q - большое простое.

В общем случае неверно, что h1=h2 => s1=s2
Мы будем рассматривать алгоритмы, в которых это верно с большой вероятностью.

Пусть мы считаем хеш-функции префиксов нашей строки:
h0, h1, h2, ... hn
Пусть есть строка s`
У строки есть хеш-функции префиксов
h0`, ... hn`

Нужно найти наибольший общий префикс.
Путь есть n строк и M запросов.
Можно искать бин. поиском позицию, в которой хеши всё ещё совпадают.
Вообще говоря лучше использовать бинарный поиск с подсказкой, чтобы искать ответ за логарифм общего префикса.
Зная наибольший общий префикс всех строк можно быстро сравнивать строки и сортировать их.

Пусть есть строка c1,...cn с хеш-функциями h1,...hn
Мы хотим найти хеш-функцию подстроки от L до R.
Несложно понять, что она равна h[r]-h[l-1]*p^(r-l+1)

Теперь с помощью хешей можно искать префикс-функцию, z-фунцию и т.д. за логарифм.

Пусть теперь нужно найти наибольшую общую построку.
Если нужно найти общую подстроку какого-то размера, то достаточно посчитать все хеш-функии первой строки и второй строки и пересечь эти множества.
Тогда можно вести бинарный поиск по ответу и искать ответ за:
log(n) * n * log(n) = n * (log(n))^2

Пусть мы ищем масимальную подстроку, являющуюся палиндромом.
Считаем хеши в прямом и обратном порядке, выбираем центральную позицию и бин-поиском ищем макс. палиндром с центром в этой позици.

Если мы можем легко проверить правильность ответа, то если он получился неправильным, можно просто выбрать другие параметры хеш-функции и снова посчитать.

Давайте построим суффиксный массив с помощью хеш-функций
Мы умеем считать хеш-функцию подстроки, значит можно искать хеш-функцию префиксов суффиксов.
Значит мы умеем быстро сравнивать и сортировать суффиксы.

Если есть строки s1 и s2 с хеш-функциями h1 и h2, то h1*p^|s2|+h2 - хеш-функция s1s2

Пусть теперь есть строка, мы хотим вычислять хеш-функцию всех её подстрок.
При этом мы можем вставлять символ в произвольное место строки.
Хочется использовать декартово дерево, в каждой вершине будет хранится симовол и значение хеш-фукции для данного поддерева.
Понятно, что значение хеш-функции действительно можно посчитать с использованием символа и значений 2 хеш-функций.
Поэтому реализуются split и merge.
Если хочется поддерживать операцию разворота подстроки, то можно вместе с хеш-функцией каждой строки хранить и поддерживать хеш-функцию перевёрнутой строки.
Методом отложенных операций всё реализуется.