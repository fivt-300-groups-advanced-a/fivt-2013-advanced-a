Сегодня мы поговорим про суффиксное дерево.
Суффиксное дерево - этого всего лишь бор, который состоит из всех суффиксов одной строки.
Если у нас есть строка s, то мы добавляем в бор первый суффикс, второй, и т. д.
Суффиксное дерево замечательно тем, что с нем есть все префиксы суффиксов данной строки, то есть любая подстрока.
Каждая вершина суффиксного дерева соответствует некоторой подстроке данной строки.
Если мы строим суффиксное дерево, как бор, то мы это делаем за O(N^2) времени и памяти.
Поэтому строим сжатое суффиксное дерево.
Будем писать на путях без разветвелий подстроку целиком - уменьшаем число вершин.
Алгоритм построения сжатого суффиксного дерева.
Строим сжатый бор. Добавляем сначала одну строку.
При добавлении очередной строки проходимся по бору. Доходим до символа, которого нет в дереве.  
Если мы находимся на конце ребра, то просто добавляем соответствующий суффикс.
Если же мы находимся в середине ребра, то просто разделим ребро на 2 и подвесим новый суффикс.
Тогда, очевидная оценка сверху на число вершин: 2n
O(N) памяти по числу вершин, очевидно всё же лучше, чем O(N^2). Плюс есть надежда, что можно дерево построить быстрее, чем за O(N^2)
У нас всё ещё O(N^2) памяти по символам, если мы храним все строки на рёбрах. 
В случае суффиксного массива можно просто хранить 2 числа: начало и конец подстроки.
В общем случае со сжатым бором такой фокус не пройдёт.
Давайте строить суффиксное дерево быстрее. Будем строить его постепенно, добавляя букву за буквой.
Сначала есть суф. дерево, для пустой строки.
Добавляем 1 вершину - появляется одно ребро.
Далее храним указатели на все концы текущих суффиксов. 
На каждой итерации добавляем ко всем вершинам с указателями новую букву и сдвигаем указатели.
Добавление i-ой буквы делается за O(i). Итого имеем O(N^2)
Здесь мы строкили не сжатое суффиксное дерево, но мы могли бы так же строить сжатое.
Будем ускорять алгоритм.
Обратим внимание на то, как мы работаем с листьями.
Если в процессе работы появляется новый лист, то на него указывает зеленый указатель на конец суффикса.
В последствии этот лист будет растягиваться - на ребре в нем добавляется одна буква.
Итак, оптимизация листа: будем на листах говорить, что строка там написана уже сразу до конца.
Давайте теперь откажемся от хранения указателей, на концы суффиксов: будем просто хранить указатель, на самый длинный суффикс, не являющийся листом.
Будем хранить суффиксную ссылку.
В сжатом суффиксном дереве мы будем хранить суффиксную ссылку во всех внутренних вершинах.
Ссылка для подстроки aA - подстрока A.
Оказывается, что суффиксная ссылка из вершини всегда ведёт в вершину (не может лежать на середине ребра)
Действительно, если в строке aA есть разветвление, то и в строке A есть развествление (по тем же буквам).
В процессе алгоритме будем поддерживать инвариант: для каждой внутренней вершине посчитана суффиксная ссылка.
Пусть указатель на самый длинный суффикс оканчивался в вершине. Пытаемся добавить новый сивол x. 
Переходим по суффиксным ссылкам, добавляя листья и останавливаем алгоритм, если переход по букве уже есть.
Пошагово
У нас построено дерево дл некоторой строки s.
Добавляем букву a.
Мы знаем указатель на самый длинный суффикс.
Если мы можем перейти по букве a, то просто сдвигаем указатель.
Если же вышло так, что мы находимся в вершине и перехода по букве a нет -
то мы добавляем новый лист, переходим по суффиксной ссылке и повторяем то же самое.
Если мы находимся в середине ребра и пытаемся добавить новую букву, и этой буквы не оказалось, то мы просто раздваиваем ребро.
Но для только что созданной вершины нет суффиксной ссылки.
Тогда просто поднимаемся к родителю на B, переходим по суффиксной ссылке и спускаемся на B.
Как именно спускаться? Используем быстрый спуск.
Если есть ребро, которое начинается на букву, то проходим по этому ребру сразу, не проверяя остальные буквы.
Таким образом, проверки нужно осуществлять только в узлах дерева.
Ну и после спуска нужно добавить новую суффиксную ссылку.

Оценим время работы.
Сколько раз мы можем просто двигаться в рамках дерева без добавления ребра? O(N) - ведь это заканчивает фазу добавления символа.
Введём потенциал - длина нашего самого длинного суффикса.
Увеличивает потенциал на 1 только переход по символу, который уже есть в дереве.
Переходы по суффиксной ссылке всегда уменьшают потенциал на 1.
В случае, если переход по суффиксной ссылке был сразу из вершины, то все просто, и все такие передохы работают за O(N).
Если переход был из середины строки, то мы точно не знаем, сколько именно операций мы проведём в процессе быстрого спуска.
То, что всё равно время работы O(N) докажем на след. лекции.