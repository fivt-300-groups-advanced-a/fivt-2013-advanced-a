"Из двух зол выбирать не стоит"

Продолжаем тему строки.
Сегодня мы рассморим z-функцию. Для заданной строки s z-функция равна наибольшему количеству символов, таких что префикс данного размера с позиции i и c начала строки совпадают.
Например, abbacabba
z[5] = 4
z[3] = 1
Можно считать, что z[0] = |s|.
Тривиальный алгоритм: O(|s|^2) или O(SUM(z[i]))
Поиск подстроки в строке с помощью z-функции работает также. В строке s$t ищем позиции в t, в которых z[i] = |s| - это начало вхождения подстроки.
С z-функцией часто проще рассуждать и применять её, в целом, проще.

Давайте искать z-функцию за линейное время.
Сначала найдём z[1] тривиальным алгоритмом.
Тривиальный алгоритм для позиции j:
z[j] = 0
while s[z[j]] == s[j + z[j]]
do ++z[j]
Давайте теперь предположим, что мы считаем z[j] и для всех предыдущих j z-функция уже подсчитана. 
Давайте будем поддерживать индекс i такой, что r = i + z[i] = max
Найдём j' = j - i - проекция j в начальном отрезке
Мы знаем z[j']
Если вышло так, что j' + z[j'] < z[i], то z[j] = z[j']
Если вышло так, что j' + z[j'] > z[i], то z[j] >= z[i] - j'
На самом деле z[j] = z[i] - j'. Если предположить, что s[z[i]] = x, то s[z[i] - j'] = x и получим s[i + z[i]] = x, что противоречит значению z[i].
Если вышло так, что j' + z[j'] == z[i], то z[j] >= z[j']
Тогда выполним тривиальный алгоритм, начиная с z[j']
Если вышло так, что j > r, то просто исполним тривиальный алгоритм с нуля.
В последних случаях(при исполнении тривиального алгоритма) увеличивается правая граница.
Значит суммарно итерациий тривиального алгоритма - O(|s|) + периодически работают 1-й и 2-й случай, которые работают за (|s|) суммарно.
Итого имеем O(|s|).

Можно также организовать поточную работу алгоритма поиска подстроки в строке: хранить значения z[i] и i, а также все значения z[j] для строки s.
Строку t также хранить не нужно, символ запрашивается только при работе тривиального алгоритма, можно просто при каждой итерации этот символ считывать.

Пусть есть образец s и текст t. Мы хотим найти подстроку s в тексте t с учетом возможных ошибок: перестановка 2 соседних символов, удаление символа, вставка символа, замена символа.
Давайте для позиции i выделим подстроку [i..i+|s|] и в подсроке найдём максимальный префикс и максимальный суффикс.
Если посреди 2 символа, посмотрим на них и задетектим перестановку 2 символов. Также можно поступить с заменой одного символа.
Если мы хотим заметить удаление символа, то рассматриваем подстроку [i..i+|s|-1] - префикс и суффикс должны состыковываться.
Чтобы посчитать информацию о наибольшем префиксе и суффиксе, посчитаем z-функцию и z-функцию для перевёрнутого текста и перевёрнутого образца.

Пусть есть строка s. Нужно найти наибольший префикс s, являющийся палиндромом.
Используем префикс-функцию в строке s$s^R.

Давайте найдём максимальный палиндром, который является подстрокой.
Обозначим z[i] - длина максимального палиндрома, с центром в позиции i.
Работаем только с нечётными палиндромами.
Считаем z[j].
Пусть i - такой индекс, что значение i + z[i] максимально.
Пусть для всех меньших значения уже посчитаны.
Найдём j' - зеркальное отражение относительно/
Если вышло так, что j+z[j] < z[i], то z[j] = z[j'].
Если j + z[j] > z[i], то z[j] = r - j
На самом деле выход за границу в центре не играет роли - играет роль только выход за внешнюю границу.
Если вышло, что j + z[j] == z[i], то досчитываем палиндром тривиально.