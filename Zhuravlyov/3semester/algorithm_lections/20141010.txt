В прошлый раз мы рассмотрели алгоритм Укконена.
Мы доказали, что количество всех действий - O(N). Осталось доказать, что суммарное время работы быстрых спусков не очень большое.
Нам нужен аромартизационный анализ. Понятно, что в худшем случае быстрый спуск может занимать время O(N).
Нужно выбрать потенциал. 
Когда мы производим спуск, увеличивается глубина указателя, который показывает на максимальный суффикс, не являющийся листом.
Возьмём потенциал равный этой величине. 
Амортизированное время работы быстрого спуска равна нулю, ведь мы делаем одну операцию и увеличиваем потенциал на 1.
Если мы стоим в вершине и спускаемся по букве, то потенциал увеличивается. Когда мы переходим к предку, потенциал уменьшается.
Что происходит при переходе по суффиксной ссылке?
Пусть есть путь от корня к некоторой вершине x и есть вершина y в которую мы переходим по суффиксной ссылке. 
Мы знаем, что для кажной вершины пути от корня к вершине x есть суффисная ссылка, ведущая в вершину на пути к вершине y от корня.
Так что мы не можем уменьшить глубину вершины. 
Максимум можно сделать уменьшение на единицу, если в первой вершине на первом пути суффиксная ссылка ведёт к корень
В общем случае происходит увеличение глубины, то есть потенциала.
Уменьшится потенциал может на 1 только при переходе к корню и к переходе по суффиксной ссылке.
При этом потенциал ограничен сверху высотой дерева - O(N). Суммарное количество уменьшений потенциала, не больше, чем O(N).
А это в свою очередь значит, что и увеличений потенциала, не больше, чем O(N). Значит общее время работы алгоритма - O(N).

Научимся решать задачки.
Пусть есть строки s и t и мы хотим найти наибольную подстроку, которая входит в оба этих текста.
s=abacaba
t=tabaabaccabaca
Строим суффиксное дерево по второй строке. 
Мы ищем в этом тексте строку s. Если просто нужно проверить наличие строки, то мы просто идём по дерево.
По факту мы в итоге будем искать наибольший входящий в данный момент суффикс рассматриваемого префикса, 
который является подстрокой во второй строке, то есть входящий в дерево.
Если мы идём по строке и вышло так, что следующей буквы нет, то нужно перейти по суффиксной ссылке.
При этом под переходом по суффиксной ссылке мы считаем переход к предку с суффиксной ссылкой, переход по этой ссылке и быстрый спуск.
Выбираем максимум из длин суффиксов всех рассмотренных префиксов.
Какое время работы? Нам нужно знать, сколько будет переходов по суффиксной ссылке 
(вспоминаем про потенциал и понимаем, что остальное будет из этого следовать)
Когда мы переходим по суффиксной ссылке левая граница рассматриваемой подстроки в исходной строке сдвигается вправо на 1.

Иногда строят суффиксное дерево s$t.
Тогда любой суффикс в дереве будет листом.
Можно для решения предыдущей задачи рассмотреть строку s$t#.
Давайте считать, что если суффикс строчки начинается в строке s, то это суффикс строки s.
Если суффикс начинается в строке t и заканчивается #, то будем считать это суфиксом строки t.
Чтобы определить, является ли конкретный суффикс суффиксом строки s или t неплохо бы знать глубину в каждой вершине.
Что же является общей подстрокой?
Если такая подстрока втречается в дереве, то из этой вершины достижим суффикс строки s, а также достижим суффикс строки t.
Чтобы найти все общие подстроки, нужно рассмотреть вершины, из которых достижимы суффиксы обоих типов.
Пометим листья соответсвующего типа. Динамикой от листьев к корню выясним достижимость.
Самую длинную найдём алгоритмом выбора максиума.

Ещё одна задача.
Пусть есть одна строка s. Хочется найти самую длинную строчку, которая встречается в строке 2 раза.
Если есть вершина, которой соответствует стока A, и после неё идёт разветвление, то значит подстрока входит хотя бы дважды.
Однако бывают деревья без разветвлений, в которых есть общие подстроки. Например, aaaaa.
Добавим с в строку доллар в конец. Теперь любой суффикс соответсвует листу.
Строка, которая встречается дважды соответствует вершине или середине ребра, из которых достижимы 2 различных листа.
Промежуточные позиции, очевидно, отбрасываются. Тогда достаточно рассмотреть все разветвления в дереве.

Усложним задачу - теперь мы хотим выбирать подстроки, которые не пересекаются.
Теперь нам подходят не все вершины, в некоторых будут пересечения.
Посмотрим расстояние до листа - оно соответствует длине суффикса после этой подстроки.
Можно для каждой вершины посчитать самое позднее и самое ранее вхождение подстроки. 
Опять же динамикой ищем минимальное и максимальное расстояние до листа.
Теперь для любой подстоки мы знаем её первое и последнее вхождение. Точнее пока только для подстрок, соответствующих вершинам.
Но ещё есть и подстоки, лежащие в середине ребра.
Пусть есть ребро из v в u. v соответсвует строке A, на ребре u->v строка B.
Ищем "правду" посередине рабра v.
Рассмотрим A+B' - середина ребра. Мы можем быть уверены, что дальше мы будем встречать символы, которые добьют B' до B.
Пусть дельта в вершине - расстояние между минимальным и максимальным встречанием.
Если вышло, что дельта в u больше длины стоки A, то ответ есть в середине ребра.
Сместиться по ребру при этом нужно именно на дельту, но не превзойти при этом длины строки A+B.

Пусть есть строки s1, ... sn. Мы хотим найти наибольную общую подстроку этих n строк.
Мы возьмём строку s1($1)s2($2)...sn($n).
Теперь у нас есть n типов суффиксов. 
Пусть мы хотим делать аналогично 2 стокам.
Для каждой вершине прийдётся хранить массив из n boolean-ов, который отвечает за то, является ли сточка суффиксом n-ого типа.
Тогда мы умеем динамикой это всё дело решать за O(n*SUM(|s[i]|)).
Хотелось бы решить задачу быстрее - избавиться от множителя n.
Путь все листья покрашены в один из цветов (в зависимости от типа суффикса)
Про каждую вершину нужно узнать, какое количество различных типов листьев из нее достижимы.
Задача вообще говоря для произвольного дерева.
Упорядочим все листья.
Мы знаем про листья, что все вершины от него до корня покрашены в этот цвет.
Хочется это пометить неявно.
В листе поставим пометку +1 - это значит что всем вершинам выше нужно сделать +1.
Однако мы прибавили слишком много. Рассмотрим все пары соседних вершин, найдём их наименьшего общего предка и сделаем -1(ему и его предкам)
Проделаем все это для каждого цвета.
Одной единой динамикой снизу вверх теперь продвинем эти изменения.
Ответом будут вершины, в которых полученное значение равно n.

Хочется в строке s найти подстоку, которая без самопересечений встречается хотя бы k раз.
Ай, да ладно, подумайте и решите сами.

Рассмотрим вместо этого естественный вопрос.
Мы в алгоритме Укконена добавляем в конец букву. 
А можно ли удалить из самого начала букву?
Ну точно нужно удалить из дерева всю строку.
Просто храним указатель на самый глубокий лист.
Если он идёт из корня - просто удаляем.
Если мы пришли не из корня, то нужно после удаления объединить некоторые ребра в одно.
Чтобы удалить ещё одну вершину, то нам нужен новый указатель на самый глубокий лист.
Просто в новой вершине переходим по суффиксной ссылке и быстрым спуском спускаемся по нужной строке.
Нужно ещё доказать, что если мы объединяем рёбра, то нет суффиксной ссылки, которая могла бы туда идти.