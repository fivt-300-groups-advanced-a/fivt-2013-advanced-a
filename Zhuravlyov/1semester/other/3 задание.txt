Новое задание: структура данных - дерево отрезков.
T - в вершине
update(l,r,G); - обновление на отрезке
get(l,r,f); - получение значения на отрезке
Segment Tree <int,min<int>,plus<int>> - пример, как это можно сделать
Размер - в параметре конструктора.
Требуем от пользователя - метаинформация для обновления и Return Type

Advanced <ReturnType,MetaInformation>
MetaInformation - то, что нужно для того, чтобо проводить операции.

push(RT* r,MIU* mi); - протолкнуть метаифнормацию к значению)
merge(MIU *cur,MIU *new); - слить 2 метаинформации
union(RT* T,RT* T) - объединить 2 Result Typ-а
^^это даёт пользователь.

Можно просить у пользователя нейтральный элемент.

Пример:
RT {
min;
sum;
} в случае с int это 2 intа

MIU {
T k;
T b;
} - умножение на положительные числа и прибавление

push (RT *r,MIU *m,int len) {
	r->min=r->min*m->k+m->b;
	r->sum=r->sum*m->k+len*m->b;
	m->k=1;
	m->b=0;
}

merge (MIU *c,MIU *u) {
	c->k=c->k*u->k;
	c->b=c->b*u->k+u->b;
}

RT union(const RT& a,const RT& b) {
	return RT(min(a.min,b.min),a.sum+b.sum);
}

Критерии:

1) 6 деревьев отрезков: min/max/sum с присвоением/прибавлением или одновременным присвоением и прибавлением с тестами (2)
2) а) stress тест на сравнение с вектором
   b) manual tests - понятные тесты, маленькие ручные
   c) внутреннее состояние дерева (inner state)
   d) integration test (3)
3) Отрезок [l,r] найти подотрезок с максимальной суммой. Присвоение на отрезке.
4) Количество отрезков постоянности на отрезке, прибавление, присвоение 0.5 + тесты(2)

// stress тест нужен для любой одной узкой спецификации дерева, inner state пишется на общее дерево, integration test - на каждую узкую спецификацию. manual test - на каждую узкую спецификацию, помимо того для каждой спецификации дерева нужно провести тестирование функтора для них.

