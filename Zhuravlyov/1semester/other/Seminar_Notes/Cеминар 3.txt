Scanf  - чтение из входного потока stdin. 
Fscanf – из файла
Scanf(“%формат”,указатели);
Примеры:
Int x; scanf(“%d”,&x); 
Char *x;scanf(“%s”,x);
Строки в C: Последовательность знаковых однобайтовых чисел с нулевым символом в конце.
Выделение буфера для строки:
Char buffer[1000];
scanf(“%s”,buffer);
scanf считывает строку до пробела.
Лучше использовать строки C++;
#include <string>
#include <iostream>
#include <fstream>
Std::string s;
Std::cin >> s;
Fread – чтение в бинарном виде
Fread(buffer, sizeof(T),1,f);
Fread(адрес, размер одного элемента, количество элементов, файл)
X – адрес, куда читать
Char b[sizeof(t)]
Reinterpret_cast<T*>(b) – «мне абсолютно неважно, какого типа b, просто возьми его байты и сделай из него тип T».
Потоковый двоичный ввод:
Ifstream in(“xyz”);
In.read(&x,sizeof(t));


Наследование в C++
Class A
{
Public:
Int f();
Int g();
Private
Int x;
};
Class B:public A{
Int h();
//Int f();
} – все публичные методы A становятся публичными методами класса B. Приватные методы остались в классе A, protected переходят в protected.

Полиморфизм
Class A {
Virtual Void say()=0
}
Class Dod: p A 
{
Override void say() {}
}
Class Cat: p A
Class Pig: p A
Say3times(animal *a) { a->say(); a->say(); a->say(); }
Virtual - Методы, объявленные виртуальными, могут быть переопределены потомками. 
Override – проверка наличия у предка этого метода
Абстрактный метод – метод, который нужно будет переопределить.
Dog d;
d.say();
say3times(&d);
нельзя: animal a=d;
Можно animal *a=&d;
Pig p;
Animal *a2=&p;
Class Pyos: p A
{
Int x;
};
В любом виртуальном классе есть дополнительные 8 байт на ссылку на таблицу виртуальных функций.
Недостаток virtual – каждый объект на 8 байт больше, вызов всех виртуальных методов работает через таблицу виртуальных функций. Преимущество – использование полиморфизма.
Пример
Istream: istream& - передается наследник stream.

Реализация полиморфизма с помощью шаблонов.
Template <class Animal>
Void say 3 times (const Animal& a) { a.say();a.say();a.say(); }
При передаче компаратора лучше использовать функтор вместо функции для оптимизации со стороны компилятора.

Для любого класса с виртуальным методом нужно писать виртуальный деструктор.
( Animal *a=new Dog(); ) – создаётся в куче
Dog d; - создается на стеке.
Delete a  - освобождение памяти.  <-> a.~Animal()


Class A {
Int x;
}
Class B: public A
{
Int y;
}
При вызове деструктора базового класса удалится только члены баллового класса.
Чтобы всё было хорошо нужно в A объявить virtual ~A() {};

(Ещё про ДЗ)
Нужно реализовать с уникальным интерфейсом: Чтение входное, временная запись, временное чтение, размер блока, Сортировка в памяти, компаратор, общий вывод.

Unit-тестирование 
Googletest
-Wiki
-Set up New Test project
Primer – примеры использования

Reader_test.cpp
#include “gtest/gtest.h”
#include “reader.h”
TEST(Binary Reader, Int Test)
{
	Int sum=2+2;
	EXPECT_EQ(4,sum);
	ASSERT_EQ(4,SUM) – прекращает выполнение функции
}
Написать ридер и врайтер по аналогии с ним.
