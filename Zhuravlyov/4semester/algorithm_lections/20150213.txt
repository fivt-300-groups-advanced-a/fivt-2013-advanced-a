Курс не будет посвящён параллельным алгоритмам.

Первая часть курса будет про вычислительную геометрию. Вторая часть курса с некоторой вероятностью будет про вероятностные алгоритмы.

Начнём с выпуклых оболочек в 2D.

Convex Hull (выпуклая оболочка). Есть набор точек p[0], p[1], ..., p[n-1]. Нужно найти минимальное выпуклое множество, содержащее данный набор точек.

Естественным образом выпуклая оболочка представляет собой многоугольник с вершинами, входящими в исходное множество.
Так что по сути задача сводится к тому, чтобы найти многоугольник, как упорядоченный набор точек.

Пусть u, v - векторы. Их скалярное произведение (u, v) = u1*v1 + u2*v2 = |u|*|v|*cos(a)
Их векторное произведение [u, v] = det{{i, j, k}, {u1, u2, u3}, {v1, v2, v3}} - вообще говоря определено в R3, но можно опредлить и для R2 как скалярную величину:
В самом деле если u3 = v3 = 0, то [u, v] = k (u1 * v2 - u2 * v1).
В 2D векторное произведение используют для определения направления поворота от одного вектора к другому.
Для векторов u и v, получим что знак выражения (u1 * v2 - u2 * v1) определит направление поворота.

Алгоритм Джарвиса. (алгоритм заворачивания подарка)

Выберем самую нижнюю левую точку из исходного множества - c[0]
От c[i] найдём вершину c[i+1] с наибольшим углом поворота от последнего рассмотренного отрезка.
Для определения максимума по углу поворота используем векторное произведение (опеределяем кратчайший поворот от одного вектора к другому.
В случае равенства угла выберем больший по длине отрезок.
Время работы O(h*n), где n - число вершин, h - число вершин в ответе.

Алгоритм Грэхема

Выберем самую нижнюю левую точку из исходного множества.
Отсортируем все остальные точки по убыванию полярного угла от данной. При равенстве полярного угла производим сортировку по расстоянию от начальной точки.
Для сравнения полярных угла используют векторное произведение - смотрим направление крат. поворота, сам угол вычислять не нужно.
Пусть отсортированный набор точек - p[1], p[2], ..., p[n-1]
Далее обходим p[i], добавляя их в стек S.
Добавляя очереднуюю точку мы проверяем, что новая добавленная точка производит правый поворот от последнего вектора (2 последние точки в стеке)
Если это не так, то все вершины в стеке удаляются, пока условие правого поворота не будет выполнено. Естественно, условие правого поворота проверяется векторным произведением.

S.push(c[0])
S.push(p[1])
for (i=2..n-1) {
  while ([(s.prev, s.top), (s.top, p[i])] <= 0) {
    s.pop();
  }
  s.push(p[i]);
}

Сложность алгоритма O(nlogn)

Алгоритм Эндрю

Улучшение алгоритма Грэхема. Сортировка производится по координате x, а при равенстве по координате y.
Далее выбираются наибольшая и наименьшая точки и рассматриваются точки в верхней и нижней полуплоскости от отрезка, их соединяющего.
Для кажной полуплоскости строится половина выпуклой оболочки так же, как и в алгоритме Грехема.

Алгоритм Чана

1) Разбиваем на группы по m элементов произвольно. r = n/m - число групп.
2) В каждой группе запускаем алгоритм Грехема. O(rmlogm)=O(nlogm)
3) Объединием найденные выпуклые оболочки модификацией алгоритма Джарвиса.
   Для каждой группы оптимальная точка выбирается с использованием бин. поиска за O(logm).
   После этого берётся лучшее значение среди всех за O(r)
Время работы O(nlogm + hrlogm)) = O(nlogm + hn/m*logm)
Если m=h, то время работы O(nlogh)
Нужно научиться подбирать такое m. Можно останавливать алгоритм, когда значение выпуклой оболочки слишком большое и увеличивать значение m.
Например, удваивая значение m, суммируя, можно получить асимптотику O(n(logh)^2)

Алгоритм "разделяй и властвуй"

1) Разбиваем точки на непересекающиеся группы вершин по не очень много вершин в группе. m=7, например
Наример, отсортируем точки по x и разобьём тем самым на группы.
Для каждой группы
2) Объединяем группы турнирным способом (как merge-sort)
Как происходит объединение 2 выпуклых оболочек?
Мы знаем, что они разделены некоторой прямой.
Идея состоит в поиске 2 общих касательных к 2 данным многоугольникам.
Изначально фиксируем самую правую вершину левого многоугольника и самую левую вершину правого многоугольника.
После этого происходит продвижение вверх отрезка: рассматриваются соответствующие повороты и исключается некоторая вершина, пока все повороты нас не будут удовлетворять.
Аналогично отрезок продвигается вних.
Время работы объединения тем самым линейное по суммарному числу вершин в 2 группах.
Поэтому суммарное время работы алгоритма O(nlogn)