Всякие алгоритмы на плоскости сегодня будут.

Поиск 2 ближайших точек на плоскости.
Разделяй и властвуй.
Упорядочиваем все точки лексикографически (сначала по x, потом по y)
Разделим множество точек пополам, в каждом найдём 2 ближайшие расстояния: h1 и h2 в левой и правой половине.
Рассмотрим множество B - точек, которые по x от средней точки отличается не более, чем на h = min(h1, h2)
Осталось научиться искать в множестве B пару ближайших точек за O(n).
Пусть мы зафиксировали точку p[i]. 
Рассмотрим множество точек, таких что y координата лежит ниже y-координаты данной вершины не больше, чем на h.
Тогда очевидно, что в таком множестве не может быть больше 7 точек.
Ну в самом деле, просто используем, то, что с каждой стороны не может быть быть достигнуто расстояние, меньше, чем h.
Мы все точки отсортируем по y.
Возьмём самую верхнюю точку, которая лежит в B.
Рассматривая новые точки, обращаем внимание только на точки, которые лежат в B.
В очередь будем добавлять те и только те точки из B, которые отличаются от текущей вершины по y-координате не больше, чем на h.
Как только достигли точки, расстояние до которой больше, чем h, берём следующую точку из очереди и отсчитываем расстояние от нее.
Можно сказать даже проще: в отсортированном по y массиве мы должны от каждой точки просмотреть не более, 
чем 7 точек, расстояние до которой не больше, чем h.
Ну на самом деле сортировка займёт больше, чем линейное время, но мы будем использовать итеративный merge-сорт, 
обеспечивая сортировку за линейное время на каждой итерации.
Итого время работы O(nlogn)

Поиск треугольника с минимальным периметром.
Делается аналогично.
Отсортируем точки p[i] лексикографически, разделим на 2 множества.
В каждом найдём минимальный периметр, получим каждое множество, отсортированное по y.
Путь l = min(l1, l2) - наименьший текущий периметр.
Достаточно от прямой разделения множеств рассмотреть точки, которые отстоят от нее не более, чем на l/2.
Теперь, сортируя по y, общий массив мы можем для каждой точки быстро находить точки, 
отстоящие от данной не больше, чем на l/2 - их опять же некоторое константное число.

Поиск диаметра множества.
Утверждается, что диаметр будет находиться на выпуклой оболочке. Достаточно решить задачу для многоугольника.
Назовём опорной прямой к данной вершине такую прямую, проходящую через неё, что многоугольник лежит по одну сторону от нее.
Пусть у нас есть 2 параллельные опорные прямые в точках A1 и A2. Пусть расстояние между ними максимально.
Тогда A1A2 перпендикулярен обоим прямым. Отсюда мы получаем, что расстояние между 2 параллельными опорными прямыми <= диаметра.
Также утверждается, что диаметр есть максимальное расстояние между параллельными опорными.
Таким образом мы рассматриваем пару опорных параллельных прямых и поворачиваем их.
Это называют методом вращающихся калиперов.
Перебираем пары параллельных опорных прямых.
Первой прямой возьмём одну из сторон. Вторую прямую проведём через точку, максимально удалённую от этой прямой.
Далее мы поворачиваем прямые. Поворачиваем 2 прямые на наименьший возможный угол одновременно. 
При одна из прямых станет отрезком многоугольника.
Итого мы научились решать задачу за O(n), ибо поротов порядка числа сторон выпуклой оболочки + построение выпуклой оболочки O(nlogn)

Поиск накрывающего прямоугольника минимального перметра.
Решать задачу будем методом вращающихся калиперов, просто их будет не 2 а 4.
Пусть мы зафиксировали некоторый участок выпуклой оболочки. Рассмотрим прямой угол, наложенный на 2 данные точки.
Достаточно очевидно, что функция длинны этого угла будет вести себя естественно: 
её оптимальное значение будет приниматься при совпадении с одной из прямых.
Поэтому действуем аналогично. Выберем некоторый стартовый покрывающий прямоугольник.
Рассмотрим 4 угла поворота до совпадения со следующей стороной в каждой вершине и будем поворачивать на минимумальный из углов.