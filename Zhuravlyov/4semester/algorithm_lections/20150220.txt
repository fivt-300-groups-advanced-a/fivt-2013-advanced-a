Продолжаем про выпуклые оболочки. Теперь и в 3D.

Полный перебор.
Перебираем все тройки  точек. Проверяем ялвяется ли данная тройка точек гранью. 
Чтобы это проверить перебираем все остальные точки и смотрим, верно ли что все они лежат с одной стороны от грани.
Опеределяем это знаком скалярного произведения с нормалью. Нормаль определяется векторным произведением.
Время работы O(n^4)
Это обобщается для k-мерного случая. 
Для проверки стороны, с которой лежит данная точка можно посчитать знак определителя, составленного из векторов грани и добавляемого вектора.
Можно действовать иначе: нормаль можно искать как коэффициенты в уравнении гиперплоскости.
Время работы O(n^(k+1) * k^3)

Заворачивание подарка
1) Ищем p[0] - точку с минимальной z-координатой O(n)
2) Ищем p[1] - угол между p[0]p[1] и осью z должен быть максимальным. O(n)
3) Ищем p[2] - точку, такую чтобы грань p[0]p[1]p[2] так, чтобы остальные точки лежали с одной стороны от этой грани. Можно за O(n^2) в лоб.
Ищем грань от некоторого незакрытого ребра по принципу максимизации угла между гранью текущей вып. оболочки этого ребра и новой доб. грани.
После этого нужно пометить ребро незакрытым и проверить также соседние рёбра, они тоже, возможно закрыты.
Утверждается, что в выпуклой оболочке линейное число рёбер и линейное число граней, поэтому время работы O(n^2)
Это следует из планарности графа выпуклой оболочки и уравнения эйлера.

Разделяй и властвуй.
Разбиваем все точки на группы по 7 точек в лексикографическом порядке.
В каждой группе строим выпуклую оболочку за O(n^4).
Теперь нужно научиться объединять выпуклые оболочки за линейное время.
Будем поддерживать выпуклые проекции на ось Oxy текущих выпуклый оболочек.
В 2-мерном случае мы умеем объединять выпуклые оболочки. 
Найдём искомые верхний и нижний отрезок и точки в 3-мерных оболочек, которые им соответствуют.
После этого нужно добавлять новые грани, переходя от верхнего добавленного ребра к нижнему ребру.
Добавляя очередной ребро мы проверяем новую добавляемую грань по принципу: 
новая плоскость должна образовывать наименьший угол с последней, то есть так же, как в алгоритме заворачиваения подарка.
То есть для объединения нам сначала нужно найти отрезок p[1]q[1] - самый верхний, соединяющий 2 выпуклые оболочки в проекции на Oxy.
Дальше строим первую грань - рассматриваем все треугольники p[1]q[1]x и минимизируем угол между нормалью к плоскости и осью Oy.
Теперь мы строим соседние грани, минимизируя угол между нормалями добавляемой плоскости и смежной с ней уже добавленной.
Также нужно выкинуть внутренности: рассмотреть все смежные вершины, запустить от них поиск в глубину, 
тем самым найдя все рёбра, лежащие внутри и не пересекающие уже добавленный путь.