__________________________
Поговорим про линковку
__________________________

2 основные вещи, которые происходят:
1) компиляция
    Для каждой фунции создаётся свой байткод. При этом что-то может заинклюдится и заинлайнится.
    Создаётся *.o файл с ассемблерными инструкциями
2) линковка
    Все функции закидываются в один большой бинарный файл и все названия функций заменяются на их адреса в этом бинарном файле.

Мы тут столкнулись с ошибкой, что есть несколько *.cc файлов и в нескольких файлах был объявлен один и тот же класс.
Да, кстати конструктор класса, в конечном счёте тоже функция.
Получилось так, что в нескольких *.cc файлов оказалось несколько одинаковых объектов.
А у линковщика при этом было 3 файла, где написано вызвать TC, и 2 файла, в которых описан TC.
Если в 2 cc файлах вы объявили 2 одинаковые функции, то должна происходить ошибка линковки. Но она в данном случае почему-то не возникла.
Если в 2 заголовочных файлах объявлено 2 TC и вы в каком-то .cc файле их заинклюдили, то у вас возникнет ошибка.
Если вы в сс файле объявляете некоторый класс, то его нужно помещать в анонимный namespace
namespace {
Class {
      
};
}
Компиляция одного cc файла не зависит от компиляции других cc файлов.
Анонимный namespace с хорошей вероятностью гарантирует защиту от создания фукнций с одинаковым именем.
Definition у класса вообще должен быть всего один.
В частности, в различные cc файлы нельзя помещать определение одного и того же класса.
Правильным решением будет поместить определение класса в .h файл

________________________
Начинаем учить Python
________________________

Вообще прийдётся вам почитать самим кое-что.
Первое отличие от C++: переменные не нужно объявлять и указывать им свой тип.
В каждый момент времени переменная имеет свой тип, но задаётся этот тип неявно.
С какой-то точки зрения, каждая переменная - это указатель.
Взятие адреса в питоне нет.
Если мы пишем b = a, то b на самом деле не копируется, а указывает на тот же элемент
Но для примитивных типов, это будет не так: это будет не указатель, а какое-то значение.
Строка - это неизменяемый элемент. 
Если мы, например, пишем a+='4', то тогда создаётся новый объект, в котором к строе будет добавлен символ '4'.
Если у вас есть imutable-объекты, то вы можете считать, что они хранятся по значению.
Фундаментальная вещь - список - массив в питоне
Объявление: z = [1, 2, 3, 4, "5", 2.0]
Как видно, в списке могут быть разнотипные элементы.
Нет никаких блоков, есть только отступы. Пробел и tab являются, таким образом, важдыми символами.
Объявление фукнции
def f(x):
    if x % 2 == 0;
        return x // 2
    else:
        return -1
Да, кстати, -1-ый элемент - это последний элемент в списке.
Как сделать цикл?
for x in z
    print(x)
Можно пробежаться по range
for x in range(10):
    print(x)
Есть while
i = 0
while i < 10:
    print(i)
    i += 1
Импорты можно делать в любом месте программы, но лучше делать это в начале программы.
import math
math.exp(53)

Динамическая инициализция списка
z = [1, 2, 3, 4, 5, 6, 7]
z2 = [x**2 for x in z]
Получим список квадратов исходгой списка.
z3 = [x * y for x in z for y in z]
что будет тем же, что и
z3 = []
for x in z:
    for y in z:
        z3.append(x * y)

Если хочется сразу по 2 спискам пробежаться:
a = [1, 2, 4]
b = ['a', 'b', 'z']
for num, name in zip(a, b):
    print(num, name)

zip - связвывает объекты в некоторый tuple
Чтобы создать двумерный массив, создайте список списков.

Есть set - оставляет только одинаковые числа.
set - hash-set, он довольно долго работает и памяти много ест.

В питоне длинная арифметика встроена и вы не можете узнать, сколько байт хранится в данном, например, числе.
x.bit_length() - показывает сколько бит в числе, но это всё ещё не количество занимаемой памяти.

Давайте объявим класс
class X:
    pass 
Это пустой класс
x = X() - создание объекта

self - аналог this

class X:
    def __str__(self):
        return  "classX"
x = X()
print(x) - напечатает classX

Функция init - конструктор класса
class X:
    def __init__(self, num):
        self.num = num
    def SetNyam(self, nyam):
        self.nyam = nyam
    def __str__(self):
        return "class X %s %s" % (self.num, self.nyam)
print(dir(x)) - все методы и параметры, которые есть у объекта.

Вообще в классе можно динамически добавлять поля во время выполнения

def SetAbc(self, x):
    self.abc = x
x.SetAbc = SetAbc

pass - значит ничего не делать
def g():
    pass
print(g()) - напечатает None
Если вы ничего не вернули - вернётся None.

qq is None - проверка на None.

Если хочется копировать объект, есть модуль copy

import copy
y = copy.copy(x) - копируются все поля
y = copy.deepcopy(x) - копируются все поля рекурсивно

Списки обычно не копируют. Обычно пишут
x = list(z)
ну или x = z[:]
Если хочется брать в промежутке:
x = z[2:5]
x = z[2:5:2] - ещё и с шагом 2

Можно проверять наличие в списке 
if 7 in z:
    print('urray')

В питоне можно переопределять все опреаторы, в частности in.

Давайте научимся наследовать классы
class Z:
    def __init__(self, x):
        self.x = x
    def Sum(self):
        return self.x
class D(Z):
    def __init__(self, y):
        super(D, self).__init__(x)
        self.y = y
    def Sum(self):
        return super(D, self).Sum() + self.y
// super(D, self) - возвращает предка D

Все методы виртуальные, все копируются, любой метод нужно переопределить

Хотелось бы, чтобы вы за след. неделю попробовали писать на python. На информатиксе можете задачки порешать

Рекомендуется установить 3 питон
Ещё ipython3
Его можно запустить в виде интерактивной консоли.
Там можно смотреть help, документацию и просто играться с запуском функции.

ipython3 notebook - веб-версия этой же интерактивной консоли

Как писать итераторы?
def my_range(size):
    i = 0
    while i < size:
        yield i
        i += 1
for i in my_range(1000):
    print(i)

yield i - прерывает функцию в текущий момент, возвращая генератор

Генератор - это фактически функция, у которой есть yield

%timeit 0.5**1000 - смотрим время работы

Следующее задание будем делать на питоне
