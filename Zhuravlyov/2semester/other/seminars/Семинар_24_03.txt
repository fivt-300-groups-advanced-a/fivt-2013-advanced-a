Хороший интерфейс - интерфейс, которым нельзя неправильно воспользоваться.
Если вам каждый раз перед x.do() нужно вызывать x.prepare(), то это плохой интерфейс.
Так вот, к вопросу о нашем графе. У нас ситуация такая, есть методы is_connected и get_incident_vertex.
is_connected можно сделать хотя бы за логарифм в случае хранения в виде списка.
При этом сортировку лучше реализовать в конструкторе. И сделать метод is_connected const.
Есть ещё getIterator() const. Он должен возвращать LIIterator.
При этом LIIterator должен быть интерфейсом.
f(LI* li) {
	LIIter* x = li.setIterator(); // здесь нужно знать, какого типа x.
}
Ну, давайте приведём пример. 
(тут код)

Нельзя возвращать абстрактный класс в качестве значения.
Нужно возвращать указатель, причёт лучше если это будет не обычный указатель, а unique_ptr.
В дефолтный конструктор класса можно передать любого наследника класса.
Так что от get_incident_vertex внутри базового класса мы избавились, вместо него теперь итератор.
Чтобы вернуть unique_ptr всегда нужно сделать std::move, чтобы значение не копировалось.
Тепрерь мы одинаково эффективно сможем реализовать и bitset и list-of-incidents.
Но теперь для реализации нового класса нужно реализовать целых 2 класса.
Как с этим можно бороться?
Можно реализовать некоторые стандартные итераторы, например IteratorByIsConnected.
Итог:
+) Теперь, благодаря итерированию всё делается более-менее быстро
-) Необходимость релизовывать новый класс

Нельзя делать шаблонный виртуальный метод, но можно делать шаблоный метод, который о чего-то наследуется.
Переопределить наследники могут только виртуальный нешаблонный метод.
Можно шаблонным указать класс, от которого будет производиться наследование.

Наследование вообще простая штука.
Если у вас есть виртуальный метод, его нужно переопределить.
Если у вас есть виртуальный объект, его нужно передавать по указателю.

std::tuple - некий кортеж.
std::tuple<int, int, double, ...>
std::get<0>(x) - получить элемет
std::tie - получает tuple из ссылок
std::ignore - ссылка, игнорирующая присваивание.
А что там за std::move? 

Ну, рассмотрим какой-то класс
class A {
	A(const A& a) {} - конструктор копирования
	A& operator=(const A& a) {} - конструктор присваивания
}
T может быть просто T, T&, T*, const T&, const T*.
В качестве rvalue может быть любой тип. В качестве lvalue может быть только T&
Ещё ввели T&& - это нужно воспринимать, как временный объект.
Для компилятора string&& - объект, который никому не нужен. 
Если вы передаёте f(string('abc')), то передаётся именно string&&.
Вы можете писать фукнции, принимающие временный объект - f(string&& s)
Например, мы хотим реализовать функцию 
NumberOfUniqueChars(string s)
{
	sort(s);
	unique(..);
	..
}
NumberOfUniqueChars(const string& s)
{
	scopy=s;
	...
}
В обоих случаят происходит копирование.
В новом стандарте можно написать
NumberOfUniqueChars(string&& s) {} - объект не копируется, а передаётся в функцию.

std::move() - позволяет явно создать временный объект, очистив старую переменную.
Однако должен быть конструктор перемещения у класса 
Конструктор перемещения выглядит так:
T(T&& x) {} - старый объект должен быть очищен.
В этом плане объекты бывают собственно перемещаемые и копируемые.

А что значит move у unique_ptr? Он просто ворует указатель и устанавливает его самого значением NULL.
У unique_ptr-а нет конструктора копирования, поэтому и нужно делать move.
Вообще если у вас есть хоть одно не копируемое поле, то сам класс не копируемый.

class X
{
	X(X&&) = default; // каждое поле класса перемещает
}
Есть type_traits. Там есть is_move_constructable<T>::value