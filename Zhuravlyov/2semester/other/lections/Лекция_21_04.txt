Продолжаем тему про кратчайшие пути в графе.
Как искать кратчайший путь между всеми парами вершин?
Алгоритм Флойда
Динамическое программирование. d[k][i][j] - кратчайший путь между вершинами i и j, где в качестве промежуточных вершин - вершины с номерами строго меньше k.
d[0][i][j] = w[i][j] или inf, если нет прямого ребра
Пересчитаем d[k+1][i][j] = min(d[k][i][j], d[k][i][k] + d[k][k][j]);
Размер матрицы O(n^3), алгоритм работает O(n^3)
Можно пересчитывать всё в одной матрице.
d[i][j] = min(d[i][k] + d[k][j])
Если в графе нет ничего плохого, то после k+1 - ого шага в матрице d[i][j] - наименьший путь с вершинами от 0 до k.
А именно не должно быть циклов отрицательного веса.
Тогда O(n^2) памяти и O(n^3) времени + у нас нет ограничения на отрицательные рёбра.
Можно весьма конкретно использовать алгоритм.
Пусть например, мы хотим посетить промежуточные вершины p1, ..., pk в поиске кратчайшего пути. Алгоритмом Флойда очевидно как это делать.
Давайте научимся восстанавливать кратчайший путь.
Заведём матрицу p[i][j] - последняя промежуточная вершина, на которой произошло обновление. 
Это будет максимальная по номеру вершина, которая существует в кратчайшем пути.
Тогда зная p[i][j] = k, востановим путь от i до k и от k до j. За длину пути восстановим ответ.
На самом деле можно восстановить путь используя просто d[i][j]. 
Просто проверим d[i][k] + d[k][j] == d[i][j] - тем самым найдём промежуточную вершину кратчайшего пути.
Те вершины которые мы при этом поиске пропустили - выкинем - они не могут лежать в кратчайшем пути.
Дальше найдём вершины, которые лежат в пути от i до k и от k до j.
Это, к сожалению, работает за O(n^2)
Как алгоритм Флойда себя ведёт, если в графе есть циклы отрицательного веса?
Если мы будем рассматривать путь из вершины i в саму себя, тогда будет рассматривать d[i][k] + d[k][i], которое может оказаться отрицательным.
Тогда на диагонали появится отрицательное число. Более того, появится оно всегда.
Если в графе есть циклы отрицательного веса, то задача, которую мы решаем - не определена.
И как будет себя в этой ситуации алгоритм Флойда? Аа, подумайте сами. 
Ну суть в том, что может произойти переполнение, т.к. числа могут после появления отр. числа на диагонали расти эскпоненциально.
В принципе, если на диагонали появилось отрицательное число, то можно просто завершить алгоритм и сказать, что мы больше не умеем ничего делать.
Но это выбор для слабых, конечно же.
Если мы увидели на диагонали отр. число, то можно заменить его сразу на -inf. И дальше уже аккуратно работать с этим числом.
А именно, если вы складываете число и -inf, то результатом должен быть -inf.
Все вершины, которые входят в циклы отрицательного веса будут гарантированно помечены.
Вот будут ли все остальные пути найдены корректно - непонятно.
Лучше после окончания алгоритма перебрать все пары вершин i, j и все пром. вершины k, и проверить следующее:
если в d[k][k] записано -inf и есть путь из i в k и из k в j, до записать в d[i][k] -inf.
А можно на самом деле смотреть на d[i][k] + d[k][k] + d[k][j] вместо d[i][k] + d[k][j] уже в изначальном Флойде.
Так что мы научились искать все циклы отрицательного веса, хоть они и могут быть немного неприятными. А точнее с восстановлением этих циклов могут быть трудности.
Давайте допустим ошибку в алгоритме Флойда.
for i
	for j
		for k
			d[i][j] = min(d[i][j] + d[k][j], d[i][j])
Что же происходит?
С помощью такого алгоритма мы найдём что-то вроде кратчайшего пути длины 2.
По окончанию алгоритм выдаст d[i][j] <= d2[i][j], где d2[i][j] - кратчайший путь длины не более 2.
d[i][j][t] = min(k)(d[i][k][t-1] + d[k][j][t]) - почти умножение матриц (обозначим *)
Если G * G = G^2 кратчайшее расстояние для =2 рёбер
G^k - кратчайшее расстояние за ровно k рёбер.
Тогда получим O(N^3 * log(k))
Кратчайшее расстояние за не более чем k рёбер?
G^0 = diag(0, inf) (нули на диагонали, на остальных местах - inf)
G = diag(inf, x) - расстояние за ровно 1 ребро - и всегда будет ровно
G = diag(0, x) - расстояние за <= 1 ребро - при таком подходе всегда будет не более.
Фактически, добавили петлю нулевого веса к каждой вершине: теперь не более чем k рёбер это и есть ровно k рёбер.
G * G - фактически итерация алгоритма Форда-Беллмана для всех вершин.

Рассмотрим просто граф, невзвешенный и его матрицу смежности.
Что такое G^2 этой матрицы?
G^2[i][j] = sum(t)(G^1[i][j] * G^1[t][j])
Фактически G^2[i][j] - количество путей длины 2 между вершинами i и j.
G^n[i][j] - длины n.
А если хочется путей длины не более n?
Можно просто просуммировать, но хочется побыстрее.
Нужно для каждой вершины j сделать вершину j', в которой сделать петлю.
В новом графе H ищем H^(t+1)[i][j'] = G[t][i][j] - все пути длиной не более, чем t.

Ну и последнее
Алгоритм Джонсона
К сожалению, Дейкстра не работает с отрицательными рёбрами.
Если мы хотим найти кратчайший путь от каждой вершины до каждой, то можно схитрить.
Если есть ребро w[i][j], то рассмотрим потенциалы p[i] и p[j]
Тогда сделаем преобразование w' = w + p[i] - p[j]
Попробуем подобрать потенциалы так, чтобы w' >= 0.
Давайте попробуем с помощью Форда-Беллмана найдём крачайший путь от вершины 0 до всех достижимых вершин - массив d
Давайте скажем, что p[i] = d[i]
Тогда w' = w + d[i] - d[j]
Сравним это с 0.
Кто больше? w + d[i] или d[j]? На самом деле w + d[i] >= d[j]
Если оно окажется меньше, то значит мы нашли неправильный кратчайший путь.
Значит w' >= 0.
Нашли потенциалы, которые переводят все рёбра в неотрицательные числа.
Теперь мы можем использовать наш алгоритм Дейкстры и за O(N*M*logN) найти все кратчайшие пути.
А что делать, если из вершины 0 достижими не все вершины? Ну просто добавим фиктивную вершину и проведем из нее рёбра до всех вершин весом 0.
Но в случае циклов отрицательного веса, увы, неравенство w + d[i] >= d[j] может быть неверно.