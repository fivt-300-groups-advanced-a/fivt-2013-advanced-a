У нас в прошлый раз возникла проблема: Дейкстра не работает в графах с рёбрами отрицательного веса.

Алгоритм Форда-Беллмана
d[0][v] - кратчайшее расстояние от вершины s до вершины v с использованием не более 0 ребер
d[0][s] = 0
d[0][v] = inf, v != s
d[i][v] - не более i рёбер
Давайте считать
d[i][v] = min(d[i-1][v], d[i-1][u] + w[u][v]), где w[u][v] - вес ребра из u в v.

Чтобы посчитать d[i] нужно O(E) времени.
Можно просматривать все рёбра. И считать динамику по-другому
d[i+1][v] = min( d[i+1][v] (old), d[i][u] + w[u][v])

Утверждается, что если нет циклов отрицательного веса, то кратчайший путь будет состоять не более чем из n-1 - ого ребра
Поэтому наше ДП можно остановить на подсчёте d[n-1][i] = d[i] - кратчайшее расстояние до вершины i.
Если в графе есть циклы отрицательного веса, это уже не работает.
Сложность алгоритма O(V*E)

Можно сделать оптимизацию - если d[i][j] = d[i+1][j] для всех j, то алгоритм можно становить

Несложно заметить, что для d[i+1][] нужно знать только d[i][], значит можно хранить только последнее d[i][] и памяти потребуется O(V)

А можно вообще только 1 массив d[] хранить
for u,v in E
    if d[v] > d[u] + w[u][v]:
        d[v] = d[u] + w[u][v]
Утверждается, что при такой реализации на i-ом шаге d[v] <= (old) d[i][v]
Такой алгоритм классический, плюс он может работать быстрее в некоторых случаях.

Таким образом, рассмотрели уже 2 модификации алгоритма Форда-Беллмана.
3 вариант
D[i][v] - кратчайшее расстояние за ровно i рёбер.
Тогда просто не нужно будет рассматривать d[i-1][v]

Недостаток 2 варианта: не даёт количество рёбер в пути.
Как понять, есть ли циклы отрицательного веса.
Проверим n-ую итерацию цикла, если произошла модификация - цикл есть.
Кроме того, если изменение произошло в вершине v, то можно точно сказать, что между s и v есть цикл отрицательного веса.

Как восстанавливать этот цикл?
Можно хранить при подсчёте динамики массивы предков p[i][v], однако это потребует O(V*V) памяти.
На самом деле можно хранить просто p[v] и динамически их пересчитывать. Утверждется, что тогда в p будет хранится цикл отрицательного веса

Мы находим только циклы отрицательного веса, достижимые из исходной вершины.
Можно просто добавить фиктивную вершину с ребрами веса 0 во все вершины, тогда найдутся все циклы отрицательного веса.

Мы научились проверять наличие цикла отрицательного веса, находить циклы, но не все.
Если мы сделали n-1 итерацию, сделали n-ю итерацию, получили модификацию в вершине v, значит v можно поставить значение -inf.
Таким образом, релаксируем вершины -inf по-очереди.
Это нужно делать, пока обновляется. И всего итераций не больше n.
