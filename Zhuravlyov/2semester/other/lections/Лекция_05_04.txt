Потоки в сетях

Сеть - ориентированнный граф, у которого для каждого ребра есть его пропускная способность c[i][j]
Есть узлы и трубы между 2 узлами. При этом c[i][j] >= 0. В этой сети жидкость может каким-либо образом путешествовать.
Потоком в сети называют некоторую величину f[i][j] - сколько воды течёт из вершины i в вершину j
Первое соображение: f[i][j] <= c[i][j]
Будем считать, что жидкость всегда течёт только в одном направлении. Если она течёт из i в j, то мы считаем, что f[i][j]>0, а f[j][i] = -f[i][j]
Таким образом, поток это величина f, для которой
f[i][j] <= c[i][j]
f[i][j] = -f[j][i] => f[i][i] = 0
Чаще всего в сети выдеделяют исток S(Source), и сток T(Target)
Для всех промежуточных вершин выполняется условие: в них вода не зарождается и не накапливается.
Что математически можно записать как:
Для любой вершины, которая не исток и не сток сумма потоков, начитающихся в этой вершине равна 0. - ещё одно условие на поток

Мы будем рассматривать сеть со стоком и истоком и будем искать максимальный поток из s в t.
Потоком называют сумму потоков f[s][i] где i - любая вершина, s - исток
Физический смысл потока - сколько жидкости в единицу времени протекает из s в t.
Скоро мы докажем, что SUM(f[s][i]) = SUM(f[i][t]), при условии, что выполнены все инварианты потока.

Разрез графа - это разбиение вершин на 2 непересекающихся мн-ва S и T, где s лежит в S, а t лежит в T.
Пропускная способность разреза - сумма пропускных способностей по всем вершинам из S и T.
С[S][T] = SUM(SUM(i in S j, in T)(c[i][j]))
Потоком через разрез называют
F[S][T] = SUM(SUM(i in S j, in T)(f[i][j]))

Докажем, что поток через любой разрез одинаковый. По индукции.
Пусть есть некоторый разрез. Какую-то одну вершину v хотим переместить из T в S.
Изменение потока:
delta = -SUM(i in S, f[i][v]) + SUM(i in T, f[v][i]) = SUM(i in S, f[v][i]) + SUM(i in T, f[v][i]) = SUM(i in V, f[v][i]) = 0
Индукционный переход доказан, как и утверждение.

Пусть есть пропускная способность C[i][j] и какой-то поток F[i][j]
Построим остаточную сеть ~C[i][j] = C[i][j] - F[i][j]
Дополняющий путь - любой путь из s в t в остаточной сети. Если он положителен, то текущий поток не максимален.
Если z - минимальное ребро в дополняющем пути, то z <= ~c[i][j] = c[i][j] - f[i][j] => f[i][j] + z <= c[i][j] - поток можно увеличить
Таким образом, мы доказали необходимость несуществования дополняющего пути для максимальности потока.

Теорема Форда-Фалкерсона гласит, что это условие является достаточным.
Пусть не существует дополняющего пути. Тогда рассмотрим S - мно-во вершин, достижимых по ребрам остаточной сети. T - множество остальных вершин.
Тогда в таком разрезе пропускная способность разреза совпадает с потоком через этот разрез.
C[S][T] = F[S][T], но мы в свойствах потока обсудили, что F[S][T] <= C[S][T], значит поток максимален для данного разреза, значит он вообще максимален.

Алгоритм Форда-Фалкерсона
Сначала положим f[i][j] = 0. Находим в остаточной сети произвольный путь из S в T. 
Находим минимальное ребро z в этом пути и проталкиваем по этому пути поток (по каждому ребру) равный z.
Когда дополняющего пути нет, найденный поток максимален.
В случае целочисленых пропускных способностей алгоритм работает за O(|f|*E), где |f| - величина потока.
Если пропускные способности иррациональны, то алгоритм может никогда не закончится.

Алгоритм Эдмонса-Карпа - улучшение пред. алгоритма
Просто будем находить кратчайший дополняющий путь обходом в ширину.

Для этого алгоритма есть более хорошая оценка сложности, докажем её.
Пусть выделены s и t.
При изменении остаточной сети кратчайшее расстояние от вершины s до какой-то другой вершины не уменьшается.
d[v] увеличивается со временем работы алгоритма.
Пусть уже есть некоторая остаточная сеть и найден некоторый кратчайший путь из s в t.
Вдоль этого пути мы провели проталкиваение нашего потока.
В результате какие-то ребра пути исчезнут, некоторые обратные ребра к этому пути добавятся.
Докажем что эти изменения не уменьшат кратчайшее расстояние ни для какой вершины.
Пусть это не так и есть какой-то путь из s в v, который короче оригинального пути в старом графе. Среди всех таких v выберем самую близкую к s.
Если этот путь не использует обратных рёбер, то он уже был в старом графе.
Пусть путь из s в v использует одно или несколько возвратных ребер. Рассмотрим последнее возвратное ребро, по которому он проходит.
Мы предполагаем, что этот путь короче любого другого пути из s в v в старом графе.
Пусть u - вершина, в которой заканчивается рассматриваемое последнее возвратное ребро.
Тогда в новом графе расстояние для u не меньше, чем в старом. А путь из u в v в старом графе и так был.
Значит путь на самом деле уменьшится не мог, противоречие.
Ну тут на самом деле проблемы, если u = v. Этот случай надо рассмотреть отдельно.

Посчитаем количество насыщающих проталкиваний - таких проталкиваний, кто какое-то ребро после него становится насыщенным.
Пусть произошло насыщающее проталкивание какого-то конкретного ребра.
Тогда если насытилось ребро i->j, то d[i]=z, а d[j]=z+1. После проталкивания ребро исчезает из остаточной сети.
Как может вернуться это ребро. Для этого должно произойти проталкиваение по обратному ребру. Для этого должно быть d[j] = z+1, d[i]=z+2,
а затем должно быть d[i] = z+2, d[j] = z+3, то есть для каждой вершины расстояние должно увеличиться хотя бы на 2.
Так как d[i]<=V, то по каждому ребру может произойти насыщающее проталкиваний не более чем V. Тогда всего проталкиваний O(V*E).
Каждое проталкивание обходом ширину совершается за O(E)
Суммарное время работы O(V*E^2)