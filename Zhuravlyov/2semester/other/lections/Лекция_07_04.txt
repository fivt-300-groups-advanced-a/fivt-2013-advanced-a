Поговорим о взвешенных графах.
У нас теперь ребро - это не просто пара вершин, а ещё и число - вес этого ребра.
Первое, что мы будем делать - это искать кратчайший путь.
Весом пути чаще всего называют сумму весов рёбер этого пути.

Самый распространённый алгоритм - алгоритм Дейкстры. (Dijkstra)
Он находит путь от вершины v до всех остальных.
Алгоритм жадный. 
В каждый момент в алгоритме есть множество чёрных вершин - вершины, про каждую из которых мы знаем кратчайшее расстояние.
Множество серых вершин - множество вершин, достижимых по одному ребру из чёрных.
Множество белых вершин - все остальные.
Что алгоритм поддерживает? Для каждой чёрной вершины он знает путь и кратчайшее расстояние.
Для каждой серой вершины - кратчайший путь, который во всех рёбрах, кроме последнего использует чёрные вершины.
Давайте поймём с чего начать алгоритм. Для вершины v расстояние равно 0 и она чёрная.
После этого, есть какое-то количество рёбер из нее. Все вершины, в которые эти рёбра ведут серые.
Соответствующие расстояния в серых вершинах равны длинне этого ребра.
Рассмотрим все серые вершины и выберем такую, до которой расстояние минимально. 
Утверждается, что эту вершину можно сделать чёрной.

Докажем это.
Пусть существует другой кратчайший путь до этой вершины. Тогда он должен использовать не только чёрные вершины.
В какой-то момент он проходит из чёрной вершины в серую. Очевидно, он ведёт в другую вершину.
То есть из вершины v мы попали в вершину x, а уже оттуда попали в u. 
При этом d[x]>=d[u], значит d[x] + z >=d[u], z - путь из x в u. При этом z неотрицательно.
Действительно, алгоритм Дейкстры находит путь в графе с неотрицательными рёбрами.

Таким образом, до вершины u наден кратчайший путь и мы можем её пометить чёрной.
Теперь мы просматриваем все рёбра из новой вершины и делаем релаксацию:
Если d[z] > d[u] + w, то d[z] = d[u] + w.
Тем самым в чёрное множество добавилась новая вершина и мы сохранили инвариант относительно серых и чёрных вершин.

То есть на каждом шаге мы просто выбираем минимум, просматривае все рёбра и обновляем пути.
Получаем O(V*x + E*y), где x - время выбора минимума, y - время обновления значения.
Какую структуру лучше использовать?
Обычная бинарная куча: O(VlogV + ElogV)
Обычный массив: O(V*V + E * 1) - эффективно для плотных графов
k-ичная куча. O(V * k*log[k](V) + E * log[k](V))
Если вы аккуратно найдёте минимум этой функции, то вы поймёте какое k нужно выбирать. Зависеть будет от плотности графа.
Фибоначчиева куча: O(V*logV + E)

Давайте что-нибудь поинтереснее
Пусть P(e) = f(w(e[i]))
e = (e1,...ek)
При этом на самом деле f может быть не только суммой, но и минимумом, и мощностью.
Давайте рассмотрим MAX. То есть считаем, что вес пути - максимальное ребро на этом пути.
Может быть среднее значение. 
Короче, существует много всяких интерпретаций.

Вообще хочется понять, каким критерием должен удовлетворять вес пути, чтобы можно было применять алгоритм Дейкстры.
Давайте вспомним просто доказательство корректности алгоритма.
Мы требовали, чтобы путь был неотрицательным.
Давайте сформулируем это в терминах P.
1) P(e[1]) <= P(e[2]) -> P(e[1]) <= P(e[2]+q)
Пояснение: если длина одног пути <= длины другого, то если мы добавим ещё рёбра, то путь уменьшиться не может.
1*) P(e) <= P(e+q) - то же самое, но проще
И сразу среднее арифметическое не подходит.
Ну, контрпример, в общем, можно придумать просто достаточно.
Какое ещё есть требование, которое мы неявно подразумеваем?
Рассмотрим P(e)  = max[1](e[i]) + max[2](e[i]) - то есть минимизируем сумму двух максимальных элементов
Мы думали, что кратчайший путь - это самый лучший путь. Но на самом деле это не всегда так, в частности, как в предыдущем примере.
Иногда лучше внезапно изменить путь.
Давайте сформулируем второй критерий
2) P(e[1]) < P(e[2]) -> P(e[1] + q) < P(e[2] + q)
К сожалению, этого всё ещё не достаточно.
Если есть 2 кратчайших пути одинакового веса, то пути не должны быть качественно разными
То есть получим:
3) P(e[1]) = P(e[2]) -> P(e[1] + q) = P(e[2] + q)
Получили по факту 2 ограничения:

1) P(e) <= (e+q)
2) P(e[1]) <= P(e[2]) -> P(e[1] + q) <= P(e[2] + q)

Этих 2 критериев действительно достаточно.
Применив наше старое доказательство в новых терминах, убедимся, что это и правда так.

Ещё один пример в алгоритме Дейкстры - динамический граф
Например, нахождение кратчайшего пути с использованием общественного транспорта.
Классическая задача - электрички.
У нас есть рёбра из u->w, а ещё есть набор весов для моментов времени.
Очевидно, что всегда лучше раньше приходить на остановку. Поэтому кажется, что алгоритм Дейкстры должен работать.
Если вершина чёрная - мы знаем наименьшее время, в которое мы можем туда попасть.
Мы рассматриваем рёбра с учётом текущего времени и обновляем серые вершины.
Действительно, все наши критерии в этой задаче не нарушены.

Точно так же можно рассаматривать задачу о пробках. 
Это когда вы знаете про каждую дорогу, с какой скоростью вы передвигаетесь по этому перекрёстку в даный момент времени.

Пусть теперь мы решаем задачу, где мы желаем попасть куда-либо к фиксированному времени, а максимизировать время отъезда.
Рассаматриваем ту же задачу в транспонированном графе.

Пусть во взвешенном графе у нас есть несколько людей, которые бегут к конкретному финишу. Ну это просто - запустим Дейкстру в трансп. графе
Куда интересней задача о поиске обласей Воронова.
Делаем то же, но тяжелее будет расставлять приоритеты при принадлежности вершины 2 областям.

Вспомним про дерево кратчайших путей - множество рёбер в путях, которые были непосредственно кратчайшими.
Как и в случае обхода в ширину у нас любой подпуть дерева - кратчайший путь.

Давайте найдём все рёбра, которые могут лежат на кратчайшем пути из s в t.
Просто запустим Дейкстру из s, и Дейкстру из t в транспонированном графе. Тогда для всех рёбер останется проверить простое равенство.

Рёбра, которые обязательно лежат на кратчайшем пути.
Если мы построим граф из рёбер, которые могул лежать на кратчайшем пути, то получим граф, в котором любой путь кратчайший.
Остнется найти такие рёбра, что любой путь через них проходит.

Хочется оптимизировать задачу в случае, когда нужно искать путь из s в t.
Пусть у каждой вершины есть потенциал pi(v)
Тогда _w = w + pi(u) - pi(v) - пребразование, причём оно не меняет кратчайших путей.
P(u,v)=SUM(_w[i]) = SUM(w[i]+pi(v[i])+pi(v[i+1]])
Потенциалы всех промежуточных вершин сократятся.
Тогда _P(u,v) = P(u,v)+(pi[u]-pi[v])
Пути, которые были кратчайшими, останутся кратчайшими.
Таким образом, мы можем поменять порядок, в котором просматриваются вершины в алгоритме Дейкстры.
Можно, например, потенциал инициализировать оценкой снизу нашего расстояния. 
Тогда вершины, которые находятся ближе, будут просматриваться раньше. 
Но мы ещё хотим, чтобы рёбра были неотрицательными. Ну, это и правда можно устроить.
