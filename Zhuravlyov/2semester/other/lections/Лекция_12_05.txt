В прошлый раз мы рассмотрели алгоритм Эдмонса-Карпа.
Более хорошее доказательство того, что после изменения остаточной сети кратчайший путь до любой вершины v стал не меньше, чем в старом.
Рассмотрим ближайшую вершину, для которой кратчайшее расстояние в новой сети меньше.
Пусть это последнее ребро было невозвратным.
Последнее ребро в этом пути было и в том, и в другом графе. В то же время для вершины, из которой ведёт это ребро наше условие выполняется.
Рассматривая неравенства с кратчайшими путями получим противоречия.
Если ребро возвратное, то так же элементарно получается противоречие.

Перейдём к изучению ещё одного алгоритма.
Проталкивание предпотока.

Предпоток - то же самое, что поток, только они умеют накапливать воду. Однако порождать воду из неоткуда нельзя.
То есть для предпотока
1) f[i][j] <=c[i][j]
2) f[i][j] = -f[j][i]
3) SUM(f[i][v]) >= 0, для всех v кроме s и t.

В процессе мы будем работать с предпотоком, но в конце у нас всё равно будет поток.
У нас есть переполненные вершины и обычные вершины. Нам нужно разгружать вершины. Если в вершине есть переполнение of,
поток f и проп. способность c, то можно пустить min(с-f, of) воды и если в результате of равен 0, то наступает локальное счастье для этой вершины.
Но если делать так всё время, то алгоритм вообще может не закончиться.
Структурируем процесс. Для каждой вершины введём высоты. Жидкость будет течь вниз. 
Если есть ребро ведёт из v в u, и h[v] >= h[v] + 2, то это ребро должно быть насыщенным.

Изначально все вершины, кроме истока будут находиться на высоте 0, в истоке будет высота N.
Первый шаг алгоритма - насытить все рёбра, в которые есть рёбра из истока. Появляется некоторое количество переполненных вершин.
Теперь берём произвольную вершину v и рассматриваем вершины, для которых h[u] = h[v] - 1. Пытаемся спустить воду по этим рёбрам.
Если таких ребёр нет или все рёбра насыщенны, то мы можем безбоязненно увеличить высоту вершины на 1.
Делаем то же самое. Повторяем до тех пор, пока есть избыточные вершины. Утверждается, что переполнение в конечной вершине будет значением макс. потока.

Если алгоритм завершается, то теореме Форда-Фалкерсона не будет дополняющего пути и поток максимальный.
Рассмотрим количество насыщающих проталкиваний. 
Если произошло протакливание из u в v, то обратное проталкиваие может произойти, если вторая вешина поднялась на высоту 2.
Тогда всего проталкиваний будет не больше, чем E*MaxH, где MaxH - максимальная высота, на которую может подняться вершина.
MaxH при этом можно оценить сверху, как 3N. Действительно, в худшем случае может получится длинная цепочка с шагом 2 к истоковой вершине.
Итого насыщающих проталкиваний O(V*E)
Ещё бывают ненасыщающие проталкивания. Они могут происходить в ребре u->v, если c-f > of[u]. Тогда вершина u перестаёт быть переполненной.
Введём потенциал равным P = SUM(h[u]), где u - переполненная. Тогда P <= V * MaxH = 3V^2
Ненасыщающие проталкивания уменьшают потенциал хотя бы на 1.
Когда потенциал увеличивается?
Например, подъём вершины увеличивает потенциал на 1. Или если происходит насыщающее проталкивание увеличивает потенциал на h[u]. 
Ненасыщающее поталкивание в худшем случае даст -1.
За счёт подъёмов и насыщающих проталкиваний получаем макс. увеличение O(V^2 + V^2*E) = O(V^2 * E)
Тогда получим, что суммарное время работы всего алгоритма составит O(V^2 * E).

Улучшение алгоритма.
Алгоритм поднять-и-в-начало
Смысл алгоритма в выборе переполненных вершин.
Все вершины, кроме стартовой и конечной поместим в двусвязный список. После этого ставим указатель на начало списка, берём вершину и спускаем воду.
Если удалось вершину освободить, то перемещаем указатель дальше. 
Если находятся в какой-то момент вершина, которую не удалось слить, то поднимаем вершину и отправляем её в начало и продолжаем алгоритм.
У каждой вершины есть список инцидентный вершин, и в каждый момент мы рассматриваем указатель на последнюю просмотренную вершину, 
т.к. уже рассмотренные вершины можно не рассматривать.
Тогда всего просмотров списков ребёр может случиться O(SUM(MaxH*d[v])) = O(V*E)
Всего мы можем начать сначала O(V * MaxH). Пройти по списку за O(V), итого O(V^3) беганий по списку.
Тогда получим, что время работы алгоритма O(V^3 + VE) = O(V^3)