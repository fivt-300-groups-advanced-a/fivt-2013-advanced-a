Лекция
Эйлеров путь \ цикл
Эйлеров путь - путь в графе, проходящий по всем рёбрам.
В неориентированном графе по ребру нужно пройти один разю
Эйлеров цикл - эйлеров путь, в котором начало совпадает с концом.
Если у нас существует в графе эйлеров цикл, значит для всех вершин этого цикла степень чётная. Это необходимое условие.
Кроме этого, неплохо бы, чтобы граф был связный, если не учитывать вершины со степенью ноль.
Оказывается, это необходимое условие, является достаточным.
В неориенитированном графе существует эйлеров путь, если не более 2 вершин нечётны, собственно, это s и t.
Для ориентированного графа соображения такие же. Количество входящих рёбер совпадает с количеством исходящих рёбер. Кроме, разве что, двух.
В одной из двух out = in + 1, в другой in = out + 1.

Давайте конструктивно построим алгоритм.
Проверим свзяность для начала.
Начнём с вершины, которая может являться стартовой. Это либо произвольная, либо та, которая нечётная, либо та, у которой больше исходящих рёбер.
В вершине s мы будем выбирать произвольное неиспользованное ребро и проходить по нему. Использованные рёбра будем помечать, и т. д. пока есть неиспользованные ребра.
Прийдём в некоторую вершину x. Давайте подумаем, что это может быть за вершина?
Пусть это неориентированный граф и степени всех вершин чётные. В таком случае, x = s. 
Действительно, если бы мы застряли в какой-то вершине, то в ней было бы нечётное число рёбер.
Можно было бы обрадоваться и сказать, что мы нашли эйлеров цикл. Но мы могли какие-то рёбра не задействовать.
Мы просто начали из вершины s и закончили в s.

Можно сказать так:
Давайте теперь удалим этот цикл и граф распадётся на много маленьких кусочков, в каждом из которых все вершины чётные. 
Теперь можно везде найти эйлеров цикл и присоединить к уже найденному.
Но я так говорить не буду =(

Мы будем делать проще. Как только мы попали в вершину, из которой мы не можем выйти, мы будем говорить, что последнее ребро, которое ведёт в вершину s - 
это последнее ребро нашего искомого пути. Если мы после этого вернулись в вершину u и из нее ещё есть какое-то неиспользованное ребро, то мы пройдём по нему, проходить по оставшимся рёбрам.
Мы остановимся, таким образом, на какой-то вершине z, так вот оказывается, что z = u, т.к. у нас всё ещё по непройденным рёбрам - все степени чётные.
Мы будем говорить, что если мы пришли в вершину и из него идти больше некуда, то это ребро будет последним(из ещё не добавленных) ребром нашего цикла. (цикл мы строим с конца)
Таким образом, алгоритм рекурсивно идёт во все подряд рёбра и выписывает искомые рёбра с конца на начало на хвосте рекурсии.
Делается это обходом в глубину.
Таким образом, если в каком-то месте, некуда идти, то мы добавляем ребро в ответ.

А почему мы пройдём по всем рёбрам?
Мы не заканчиваем алгоритм, пока вообще все рёбра не будут пройдены.
Почему это Эйлеров цикл. Да ровно потому что он по каждому ребру проходит по одному разу, а рёбра в нём идут по порядку.

Если мы ищем Эйлеров путь, то после старта из вершины s, эта вершина станет чётной и единственной нечётной вершиной будет t.
Таким образом, тот же алгоритм остановится в t. Добавив рекурсивное восстановление ответа, получим алгоритм поиска эйлерова пути.

Кстати, чётной вершиной в неориентированном графе называют вершину, у которой in = out, а в неориентированном - количество инцидентных рёбер чётное.
Мы конструктивно научились строить эйлеров цикл, тем самым доказали достаточность критерия:
Для цикла: все вершины чётные 
Для пути: все вершины, кроме s и t чётные, для s: in = out - 1, для t: in = out + 1

Давайте попробуем оценить время работы.
Вроде бы это и обход в глубину, но вершины-то мы не помечаем, а помечаем только рёбра.
Давайте вообще реализацию напишем
dfs(f):
while	e = getRndEdge(v)
	mark(e);
	dfs(e.u); // вершина, куда указывает ребро
ans.push_back(parent_edge);
Но из одной вершины можно пойти по нескольким рёбрам.
Если мы можем брать случайное ребро за O(1), то алгоритм работает O(E).
Частая ошибка в реализации:
for i=0 to n do:
 if is_con[v][i] ... // каждый раз случайное ребро берётся очень долго.
Вы войдёте каждую вершину O(E) раз и сделаете O(V) операций. Итого O(VE)
Можно поставить счётчик: s[v], и делать не i=0 to n, a i=s[v] to n, что не сильно спасёт ситуацию
Правильный цикл
while s[v] < n : 
	u = s[v];
	s[v]++;
...
Таким образом, получаем нужное время работы.
На самом деле стек рекурсии в этом алгоритме может достигать E. Порой, может стека не хватить.

Переходим к обходу в ширину.

Многие знают, но расскажу.
Работает со невзвешенным ориентированным графом.
Волновой алгоритм.
До вершины s расстояние равно 0, для всех соседей расстояние равно 1. Просмотрим рёбра из 1 в вершины, расстояние до которых неизвестно. 
До них будет расстояне 2.
Такой алгоритм работает за O(V^2 + E)
Обход в ширину отличается от такого алгоритма тем, что мы заводим очередь.
Сперва туда добавляем s с расстоянием 0, добавляем вершины с расстоянием 1, обрабатываем вершины с расстоянием 1 и т. д.
Каждый раз в очереди находится вершина с наименьшим расстоянием из нам известных.
Вообще в очереди не может быть больше двух слоёв: с расстоянием d и расстоянием d+1.
Этот инвариант позволяет определить максимальный размер очереди, который может быть достигнут.
Слои имеют вполне конкретную структуру в зависимости от задачи.
Если мы решаем задачу для доски NxN, то максимальный размер очереди - O(N)
Время работы обхода в ширину - O(V+E)
Ну ладно, в целом с обходом в ширину понятно.

Мы сейчас научимся использовать для решения не O(N) памяти, а O(MLS) памяти
Давайте поймём, какую информацию нужно знать в обходе в ширину, чтобы успешно его завершить.
Мы хотим избавиться от хранения пометки вершины графа.
На самом деле граф неориентированный, и в текущий момент мы находимся в вершине x, до которой расстояние d.
Нам достаточно хранить пометки для вершин с расстоянием d, d-1, d-2. Их можно хранить в сбалансированном дереве. Лиший логарифм по времени, зато память хороша.
Таким образом, мы должны хранить 3 последних слоя очереди.

Давайте посмотрим на остовное дерево обхода в ширину - дерево кратчайших путей.
Оно замечательно тем, что в нем любой путь - кратчайший. Давайте посмотрим, какие рёбра могут быть, которые не вошли в дерево кратчайших путей.
В случае неориентированного графа, оно может идти на один уровень выше, на два уровня выше, на тот же уровень.
В случае ориентированного графа, ребро может идти сколь угодно назад. Однако вниз можно пойти максимум на единицу.

Давайте быстренько решим задачу - 0-1 BFS
Пусть в графе у нас теперь взвешенные рёбра. Но вес на самом деле бывает только 0 или 1.
Делаем тот же обход в ширину, но с некоторой модификацией.
Пусть у нас та же очередь с двумя слоями.
Берём вершину x, удаляем из очереди.
Если из вершины x ведёт ребро 1 в вершину y, то если d[y] > d[x] + 1, то добавляем в конец очереди вершину.
Если из вершины x ведёр ребро 0 в вершину z, то, если d[z] > d[y], то добавляем вершину в начало очереди. 
Получаем дэк вместо очереди.
На самом деле, вершина в очередь не может попасть больше 2 раз.
Дополнительно будет пометка, рассматривали мы вершину или нет, если да - то мы эту вершину пропускаем.
Время работы, таким образом O(V+E)

Ещё одна задача 
Пусть веса рёбер 1 - k, где k - целое число, веса рёбер целые.
Если k не очень большое, то можно решать след. образом.
Можно каждой вершине сделать несколько фиктивных: v-1, v-2, ... v-k, с фиктивными невзвешенными рёбрами.
Таким образом, получим вместо взвешенного графа невзешенный.
Количество вершин в новом графе - V*k, 
Количество рёбер - E + V*k
Время работы O(E + V*k)
Есть альтернатива: взять каждое ребро и его разбить, но тогда будет много рёбер, что отразится на асимптотике.

Последняя задачка
У нас есть ориентированный граф и у нас есть некоторый финиш f.
Есть некоторое количество конкурсантов, которые находятся в s1, s2, ... sk
Хочется знать, какой из контестантов прийдёт первым.
Траспонируем граф и запустим BFS из F.
А что если теперь мы хотим для каждого участника знать набор расположений финиша, при которых он станет победителем.
То есть про каждую вершину хочется сказать, кто победит, если она будет финишом.
Можно запускать BFS сразу от всех вершин. Тогда для каждой вершины мы знаем кратчайший путь от одной из данных вершин. Восстановив, откуда взялся минимум расстояний,
восстановим и нужного контестанта.
Если есть приоритет в случае равенства, то достаточно помещать в очередь в порядке уменьшения приоритетов.
В геометрии, кстати, это называют областями Воронова.