Сегодня мы говорим про остовные деревья
Мы уже строили остовные деревья, когда делали обход в глубину.
Вообще остовным деревом называют множество рёбер графа, которое является деревом и соединяет все вершины.
На этой лекции мы будем искать минимальное остовное дерево.
В заданном неориентированном взвешенном графе нужно найти остовное дерево наименьшего суммарного веса.
Когда такая задача вообще нужна?
Вам, возможно, нужно составить сеть дорог при этом нужно минимизировать суммарную стоимость их постройки.
Перейдём сразу к основной теореме.
Пусть есть некоторый разрез графа - разбиение графа на 2 множества вершин: S и T
Посмотрим на рёбра, соединяющие вершины из S и вершины из T. Рассмотрим такое ребро минимального веса.
Утверждается, что тогда найдётся минимальное остовное дерево, которое содержит это ребро.
Пусть существует остовное дерево наименьшего веса, которое не содержит наше ребро. Пусть наше ребро соединяет 2 вершины: u и v.
Давайте найдём путь между u и v. Т.к. они в разных частях разреза, то найдётся ребро на пути между ними, которое соединяет вершины из разных частей разреза.
На самом деле можно любое ребро этого пути заменить на ребро из u в v, сохранив свойство остовности. В самом деле, удалим старое ребро и добавим новое.
Получили вес нового дерева, не превосходящий вес старого дерева. Значит исходное предположение было неверно, противоречие.
Тогда как нам найти какое-то ребро, которое входит в минимальное остовное дерево? Выберем любой разрез и минимальное ребро соответственно.
Но кроме первого шага нам теорема ничего сделать пока что не позволяет.
Рассмотрим какое-то множество уже зафиксированных рёбер. Они образуют какой-то лес. 
Проводим произвольный разрез, такой, чтобы отдельные деревья леса находились в одной части разреза.
Рассмотрим минимальное ребро в нашем разрезе. Оно должно входить в какое-то минимальное остовное дерево.
Доказательство абсолютно такое же, как и в предыдущем случае.
Эта теорема даёт нам право конструктивно добавлять рёбра.

Алгоритм Краскала
Давайте возьмём минимальное ребро в нашем графе. Очевидно, что существует разрез, в котором оно минимально. Значит это ребро может быть в минимальном остовном дереве.
Далее будем по-очереди добавлять рёбра.
Рассмотрим множество уже выбранных рёбер. Нужно выбрать ребро из разных КС минимального веса.
Для реализации просто отсортируем все рёбра по возрастанию веса. 
Добавляя рёбра, будем проверять, что 2 вершины лежат в разных КС. Для проверки этого факта удобно использовать СНМ.
Время работы O(E*logE + E*(log*)V) = O(E * log V)

Алгоритм Прима
Он строит не произвольный лес, а некоторое фиксированное дерево.
В каждый момент мы смотрим на множество вершин в текущем дереве: одна часть разреза и на все остальные вершины - другая часть разреза.
Выбираем соответсвенно минимум из ребёр по этим 2 частях разреза.
Просто на каждом шаге берём минимум из всех рёбер из уже добавленных в дерево в ещё не посещённые вершины.
Ну тут почти что алгоритм Дейкстры.
Если используем любую кучу получим время работы O(E * logV)

Алгоритм Борувка
В каждый момент у него построен некоторый лес рёбер, которые точно войдут в остовное дерево. Алгоритм рассматривает сразу много разрезов. 
Он берёт кадое дерево, помещает его в одну часть разреза, а остальные рёбра - в другую часть разреза.
То есть если у нас есть 3 компоненты в лесу, то мы будем рассматривать 3 различных разреза.
Для каждого разреза(то есть для каждой компоненты) найдём минимальное ребро, которое из нее ведёт.
Фактически задали функциональный граф, в нём, кстати, всегда есть циклы.
Если у нас есть цепочка в этом графе без циклов, то можно сразу взять все рёбра этой цепочки.
На самом деле, если ввести строгий порядок на всех рёбрах, то цикл будет только в конце пути и длины 2.
Значит можно добавить все рёбра, которые возникают в этом нашем пути.
Для каждой вершины находим минимальное исходящее ребро. Все эти рёбра добавляем, считаем все получившиеся КС.
Находим для каждой КС самое минимальное исходящее ребро, опять добавляем.
Повторяем до тех пор, пока у нас не будет ровно одна КС.
Наименьшее количество рёбер, которое мы можем добавить - это K/2, где K - количество компонент связности.
Поэтому после каждой итерации количество компонент связности уменьшается как минимум вдвое.
Можно вообще каждый раз заново искать компоненты связности и за O(E) искать минимальное исходящее из нее ребро. 
Всего таких операций мы сделаем не более log(V)
Итого получим O(E*log(V))
На практике алгоритм работает очень быстро по сравнению с остальными алгоритмами.

Задача
Для остовного дерева рассмотрим веса ребёр w[i] этого дерева и приоритеты у каждого ребра p[i].
Хочется минимизировать величину sum(p[i]*w[i])/sum(p[i])
Мы можем решать задачу на проверку того, можно ли построить дерево, в которой эта величина <= C
Преобразуем: SUM(p[i]*(w[i]-C)) <= 0
Теперь весом ребра назовём p[i]*(w[i] - C)
С этими весами найдём это остовное дерево, если оно неположительно, значит существует такое остовное дерево, функция от которого <= C
Бинарным поиском получаем поиск численного ответа с определённой точностью.
Время работы O(E * log(V) * log(D)) D - желаемая точность.