Продолжим про потоки

Блокирующий поток. Задана сеть S -> T.
Поток называется блокирующим, если не существует дополняющего пути в остаточной сети вида ~c[i][j] = c[i][j] - max(f[i][j], 0)

Алгоритм нахождения блокирующего потока в ациклическом графе.
Давайте будем запускать обход в глубину из вершины S по рёбрам остаточной сети. 
Пусть найден произвольный путь, давайте протолкнём по этому пути поток величиной в минимальное ребро.
При этом если мы пришли в какую-то вершину, из которой нет пути в вершину t, то в блокирующем потоке этот путь не появится.
Таким образом, если обход глубину в какой-то вершине заканчивается, то помечаем веришну как заблокированную.
Если найден путь, то все пометки вдоль пути сбрасываются.
Кроме того, если мы проходили по какому-то ребро, то не нужно проходить по нему второй раз, 
поэтому нужно хранить указатель на последнее просмотренное ребро в каждой вершине.
Удалений рёбер не больше O(E), всего может найтись не более O(E) дополняющих путей. При каждом нахождении погибает максимум одно ребро.
На одной итерации нахождения пути из вершины S в вершину T получается O(V) операций.
Так что блокирующий поток находится за O(V*E)
На самом деле в графе с циклами никакой разницы нет и оценка будет точно такая же.

Пусть пропускные способности бывают только величиной 0 или 1. Можно ли тогда улучшить оценку времени работы алгоритма?
При поиске пути из S в T умирают все рёбра на этом пути и тогда время работы алгоритма O(E)

Для целочисленных графов можно построить оценку O(sum(c[i][j])) - просто заменяем ребро на несколько ребёр пропускной способности 1.

Алгоритм Динницы

Состоит из нескольких шагов.
Сперва строим дерево обхода в ширину из стартовой вершины S. После этого граф разбивается на слои обхода в ширину.
Рассматриваем рёбра, ведущие только между разными слоями в нашем дереве. Рёбра u->v, для которых d[u]=d[v]-1
В этом графе любой путь из вершины S в вершину T - кратчайший.
Найдём в этом графе блокирующий поток и прибавим его к ответу.
Кратчайшее расстояние до всех в алгоритме Диница не может уменьшиться, как и в алгоритме Эдмонса-Карпа
Кроме того, расстояние от вершины S в вершину T может только увеличиться, оно не может остаться прежним. (оставим в качестве упражнения)

Одна фаза алгоритма Динницы
1) Обход в ширину O(E)
2) Блокирующий поток O(VE)
За одну фазу расстояние от вершины S в вершину T увеличивается по крайней мере на 1. Значит фаз не больше O(V)

Итого оценка для алгоритма Динницы (V^2*E)
Для 0-1 графов: оценка O(V*E), для целочисленных: O(V*SUM(c[i][j])
Попытаемся ещё улучшить оценку для 0-1 графов. 
Если рассмотреть первые sqrt(E) фаз и для нее рассмотреть старую оценку, то время работы O(E*sqrt(E)), 
вторая фаза из оценки Форда-Фалкерсона также займёт O(E*sqrt(E), тогда получим оценку O(E*sqrt(E)), 
что чуть лучше для разрешенных графов.
Рассмотрим целочисленные графы. Пусть W = SUM(c[i][j]). Рассмотрим теперь первые sqrt(W) шагов, они работают за W*sqrt(W), 
вторая часть работает за sqrt(W)*E.

Рассмотрим классический пример использования 0-1 графов
Путь мы ищем максимальное паросочетание в двудольном графе.
Двудольный граф - это например люди, а ребро - их способность вступить в брак.
Если раньше это было двудольным графом, то в современных тенденциях этот граф вообще произвольный.
Паросочетание - множество ребер, где никакие 2 ребра не имеют общей вершины.
Задача о поиске максимального паросочетания сводится к задаче о поиске потока в сети.
Возьмём истоковую вершину, проведём рёбра из S в вершины первой доли. Проведём рёбра из второй доли в стоковые вершины.
Пусть все рёбра имеют пропускную способность 1. Тогда величина макс потока будет совпадать в мощностью максимального паросочетания. 
На самом деле здесь будет работать оценка O(sqrt(V)*E) - алгоритм Хопкрофта - Карпа нахождения максимального паросочетания