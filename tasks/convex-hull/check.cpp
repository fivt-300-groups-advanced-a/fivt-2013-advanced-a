/* Autogenerated code, forces testlib to return exit codes for EJUDGE. */
#define EJUDGE

#define _USE_MATH_DEFINES

#include "testlib.h"

#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cassert>

#include <algorithm>
#include <vector>
#include <set>
#include <map>

using namespace std;

#define forn(i, n) for (int i = 0; i < (int)(n); i++)
#define mp make_pair

#define CHECK(f, a) { if (!(a)) quitf(f, #a); }
#define ASSERT(a) CHECK(_fail, a)

typedef long double dbl;

const dbl eps1 = 1e-13;
const dbl eps2 = 1e-8;

struct pnt 
{
  dbl x, y;

  pnt( dbl x_ = 0, dbl y_ = 0 ) { x = x_, y = y_; }

  void read( InStream &in ) 
  {
    x = in.readInt(); 
    y = in.readInt(); 
  }

  void out()
  {
    fprintf(stderr, "%.20lf %.20lf\n", (double)x, (double)y);
  }

  pnt operator + ( pnt b ) { return pnt(x + b.x, y + b.y); }
  pnt operator - ( pnt b ) { return pnt(x - b.x, y - b.y); }
  pnt operator / ( dbl k ) { return pnt(x / k, y / k); }
  dbl operator * ( pnt b ) { return x * b.y - y * b.x; }
  
  dbl ang() { return atan2(y, x); }
  dbl d() { return sqrt(x * x + y * y); }

  bool operator < ( pnt a ) const { return mp(x, y) < mp(a.x, a.y); }
  bool operator == ( pnt a ) const { return mp(x, y) == mp(a.x, a.y); }
};

// Checks, if polygon is oriented in clockwise order
int IsClockwise( int n, pnt *p )
{
  dbl s = 0;
  forn(i, n)
    s += p[i] * p[(i + 1) % n];
  return s < -0.5;
}

const int maxn = (int)2e5 + 10;

int n, k;
pnt x[maxn], p[maxn];
dbl ang[maxn];
set <pnt> a;
map <pnt, int> b;

int main( int argc, char *argv[] )
{
  registerTestlibCmd(argc, argv);

  n = inf.readInt();
  forn(i, n)
  {
    x[i].read(inf);
    a.insert(x[i]);
  }

  k = ouf.readInt();
  CHECK(_wa, k <= n);
  forn(i, k)
  {
    p[i].read(ouf);
    if (!a.count(p[i]))
      quitf(_wa, "%d-th of %d points in convex hull is NOT from the initial set", i + 1, k);
    if (b.count(p[i]))
      quitf(_wa, "%d-th and %d-th points in output coincide", i + 1, b[p[i]] + 1);
    b[p[i]] = i;
  }
  if (IsClockwise(k, p))
    reverse(p, p + k);
  forn(i, 2)
    p[k + i] = p[i];

  if (k <= 2)
    quitf(_wa, "contestant says, convex hull consists of less than 3 vertices");

  forn(i, k)
  {
    dbl f = (p[i + 1] - p[i]) * (p[i + 2] - p[i + 1]);
    if (f < -0.5)
      quitf(_wa, "i=%d => [i,i+1,i+2] are not convex", i);
    if (f < 0.5)
      quitf(_wa, "i=%d => [i,i+1,i+2] lie on the same line", i);
  }

  int l = 0, r = 0;
  forn(i, k)
  {
    if (p[i].x < p[l].x)
      l = i;
    if (p[i].x > p[r].x)
      r = i;
  }

  for (int i = l; i != r; i = (i + 1) % k)
    if (p[i + 1].x < p[i].x)
      quitf(_wa, "not convex (increasing chain of X-coordinates)");
  for (int i = r; i != l; i = (i + 1) % k)
    if (p[i + 1].x > p[i].x)
      quitf(_wa, "not convex (decreasing chain of X-coordinates)");

  // Check, all points are inside
  swap(k, n);
  
  dbl s = 0;
  pnt c;
  forn(i, n)
  {
    s += p[i] * p[i + 1];
    c = c + p[i];
  }
  c = c / n;
  if (s < 0)
    reverse(p, p + n + 1);
  forn(i, n + 1)
  {
    ang[i] = (p[i] = p[i] - c).ang();
    if (i && ang[i] < ang[i - 1])
      ang[i] += 2 * M_PI;
  }

  forn(i, k)
  {
    pnt q = x[i] - c;
    if (fabs(q.x) + fabs(q.y) < eps2)
    {
      // puts("INSIDE");
      continue;
    }
    dbl a = q.ang();
    if (a + eps1 < ang[0])
      a += 2 * M_PI;

    int l = 1, r = n, m;
    while (l < r)
      if (a > ang[m = (l + r) / 2] - eps1)
        l = m + 1;
      else
        r = m;

    s = (q - p[l]) * (p[l] - p[l - 1]);

/*
    fprintf(stderr, "s = %.20lf, len = %.20lf, l = %d, n = %d\n", (double)s, (double)(p[l] - p[l - 1]).d(), l, n);
    p[l].out();
    p[l - 1].out();
*/
    
    if (fabs(s) < eps2 * (p[l] - p[l - 1]).d() &&
        min(p[l].x, p[l - 1].x) - eps2 < q.x && q.x < max(p[l].x, p[l - 1].x) + eps2 &&
        min(p[l].y, p[l - 1].y) - eps2 < q.y && q.y < max(p[l].y, p[l - 1].y) + eps2)
      ; //puts("BORDER");
    else if (s < 0)
      ; //puts("INSIDE");
    else
      quitf(_wa, "Error: %d-th point of initial set is OUTSIDE of the convex hull", i + 1);
  }
  swap(n, k);

  quitf(_ok, "n=%d k=%d", n, k);
  return 0;
}
