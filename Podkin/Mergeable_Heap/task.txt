1 - куча + интеграйшн тест
2 - модульное тестирование (проверить работу операции, генерировать кучи разного вида)
3 - проверка инвариантов (стресс тест)
4 - поддержка произвольного типа, компаратор + тестирование собственного типа
5 - операции decrease_key, удаление произвольного

сдача = 25 ноября!

биномиальное дерево:
    оно биномиальное - потмоу что на каждом уровне С из н по и вершин
    глубина Сн = н
    всего вершин 2 в н
    merge 2 куч одинокового порядка - выбрать из корней макс, присобачить его слева к другому корню
биномиальная куча:
    много биномиальных деревьев
    все деревья разного порядка!
    например если в этой куче 10 элементов, то она из 2 бин. деревьев - размера 8 и размера 2
    getMin поиск минимума
        поиск мин корня среди всех деревьев, в итоге за лог
    merge делаем как в сложении двоичных чисел, работает за длину в двоичной записи размера кучи, а значит за лог
        если 1 куча порядка 0 (К, 0) - записываем К
        если 0 - записываем 0
        если 2 (К1, К2)- - записываем 0 и запоминаем К1+К2
    extractMin выбираем минимум среди корней, удаляем корень, тогда то что было раньше деревом
    распадается на i деревьев разных размеров, что есть куча - складываем старую с этой 
    decreaseKey - это обычное просеивание вверх.
    delete - сначала делаем элемент меньшим корня того дерева, в котором он находитя (минус инф например), делаем decreaseKey и extractMin;
    increaseKey - делаем delete текущего элемента, и потом merge с новым уже увеличенным элементом
    ВСЕ ЗА ЛОГ !11!!11


